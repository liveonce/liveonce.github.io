<!DOCTYPE html>
<html lang="en">

<!-- Head tag -->
<head>

    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">

    <!--Description-->
    

    <!--Author-->
    

    <!--Open Graph Title-->
    
        <meta property="og:title" content="Live Once"/>
    

    <!--Open Graph Description-->
    

    <!--Open Graph Site Name-->
    <meta property="og:site_name" content="Live Once"/>

    <!--Type page-->
    
        <meta property="og:type" content="website" />
    

    <!--Page Cover-->
    

    <meta name="twitter:card" content="summary" />
    

    <!-- Title -->
    
    <title>Live Once</title>

    <!-- Bootstrap Core CSS -->
    <link rel="stylesheet" href="//maxcdn.bootstrapcdn.com/bootstrap/4.0.0-alpha.2/css/bootstrap.min.css" integrity="sha384-y3tfxAZXuh4HwSYylfB+J125MxIs6mR5FOHamPBG064zB+AFeWH94NdvaCBm8qnd" crossorigin="anonymous">

    <!-- Custom Fonts -->
    <link href="//maxcdn.bootstrapcdn.com/font-awesome/4.6.3/css/font-awesome.min.css" rel="stylesheet" type="text/css">

    <!-- HTML5 Shim and Respond.js IE8 support of HTML5 elements and media queries -->
    <!-- WARNING: Respond.js doesn't work if you view the page via file:// -->
    <!--[if lt IE 9]>
        <script src="//oss.maxcdn.com/libs/html5shiv/3.7.0/html5shiv.js"></script>
        <script src="//oss.maxcdn.com/libs/respond.js/1.4.2/respond.min.js"></script>
    <![endif]-->

    <!-- Gallery -->
    <link href="//cdnjs.cloudflare.com/ajax/libs/featherlight/1.3.5/featherlight.min.css" type="text/css" rel="stylesheet" />

    <!-- Custom CSS -->
    <link rel="stylesheet" href="/css/style.css">

    <!-- Google Analytics -->
    


</head>


<body>

<div class="bg-gradient"></div>
<div class="bg-pattern"></div>

<!-- Menu -->
<!--Menu Links and Overlay-->
<div class="menu-bg">
    <div class="menu-container">
        <ul>
            
            <li class="menu-item">
                <a href="/">
                    Home
                </a>
            </li>
            
            <li class="menu-item">
                <a href="/archives">
                    Archives
                </a>
            </li>
            
        </ul>
    </div>
</div>

<!--Hamburger Icon-->
<nav>
    <a href="#menu"></a>
</nav>

<div class="container">

    <!-- Main Content -->
    <div class="row">
    <div class="col-sm-12">

        <!--Title and Logo-->
        <header>
    <div class="logo">
        <a href="/"><i class="logo-icon fa fa-cube" aria-hidden="true"></i></a>
        
            <h1 id="main-title" class="title">Live Once</h1>
        
    </div>
</header>

        <section class="main">
            
                
<div class="post">

    <div class="post-header index">
        <h1 class="title">
            <a href="/2018/08/16/MySQL/">
                MySQL
            </a>
        </h1>
        <div class="post-info">
            
                <span class="date">2018-08-16</span>
            
            
            
        </div>
    </div>

    
        <div class="content">
            <h1 id="一、索引"><a href="#一、索引" class="headerlink" title="一、索引"></a>一、索引</h1><h2 id="B-Tree-原理"><a href="#B-Tree-原理" class="headerlink" title="B+ Tree 原理"></a>B+ Tree 原理</h2><h3 id="1-数据结构"><a href="#1-数据结构" class="headerlink" title="1. 数据结构"></a>1. 数据结构</h3><p>B Tree 指的是 Balance Tree，也就是平衡树。平衡树是一颗查找树，并且所有叶子节点位于同一层。</p>
<p>B+ Tree 是基于 B Tree 和叶子节点顺序访问指针进行实现，它具有 B Tree 的平衡性，并且通过顺序访问指针来提高区间查询的性能。</p>
<p>在 B+ Tree 中，一个节点中的 key 从左到右非递减排列，如果某个指针的左右相邻 key 分别是 keyi 和 keyi+1，且不为 null，则该指针指向节点的所有 key 大于等于 keyi 且小于等于 keyi+1。</p>
<p><img src="https://github.com/CyC2018/CS-Notes/raw/master/pics/061c88c1-572f-424f-b580-9cbce903a3fe.png" alt=""></p>
<h3 id="2-操作"><a href="#2-操作" class="headerlink" title="2. 操作"></a>2. 操作</h3><p>进行查找操作时，首先在根节点进行二分查找，找到一个 key 所在的指针，然后递归地在指针所指向的节点进行查找。直到查找到叶子节点，然后在叶子节点上进行二分查找，找出 key 所对应的 data。</p>
<p>插入删除操作记录会破坏平衡树的平衡性，因此在插入删除操作之后，需要对树进行一个分裂、合并、旋转等操作来维护平衡性。</p>
<h3 id="3-与红黑树的比较"><a href="#3-与红黑树的比较" class="headerlink" title="3. 与红黑树的比较"></a>3. 与红黑树的比较</h3><p>红黑树等平衡树也可以用来实现索引，但是文件系统及数据库系统普遍采用 B+ Tree 作为索引结构，主要有以下两个原因：</p>
<p>（一）更少的查找次数</p>
<p>平衡树查找操作的时间复杂度等于树高 h，而树高大致为 O(h)=O(logdN)，其中 d 为每个节点的出度。</p>
<p>红黑树的出度为 2，而 B+ Tree 的出度一般都非常大，所以红黑树的树高 h 很明显比 B+ Tree 大非常多，检索的次数也就更多。</p>
<p>（二）利用计算机预读特性</p>
<p>为了减少磁盘 I/O，磁盘往往不是严格按需读取，而是每次都会预读。预读过程中，磁盘进行顺序读取，顺序读取不需要进行磁盘寻道，并且只需要很短的旋转时间，因此速度会非常快。</p>
<p>操作系统一般将内存和磁盘分割成固态大小的块，每一块称为一页，内存与磁盘以页为单位交换数据。数据库系统将索引的一个节点的大小设置为页的大小，使得一次 I/O 就能完全载入一个节点，并且可以利用预读特性，相邻的节点也能够被预先载入。</p>
<h2 id="MySQL-索引"><a href="#MySQL-索引" class="headerlink" title="MySQL 索引"></a>MySQL 索引</h2><p>索引是在存储引擎层实现的，而不是在服务器层实现的，所以不同存储引擎具有不同的索引类型和实现。</p>
<h3 id="1-B-Tree-索引"><a href="#1-B-Tree-索引" class="headerlink" title="1. B+Tree 索引"></a>1. B+Tree 索引</h3><p>是大多数 MySQL 存储引擎的默认索引类型。</p>
<p>因为不再需要进行全表扫描，只需要对树进行搜索即可，因此查找速度快很多。除了用于查找，还可以用于排序和分组。</p>
<p>可以指定多个列作为索引列，多个索引列共同组成键。</p>
<p>适用于全键值、键值范围和键前缀查找，其中键前缀查找只适用于最左前缀查找。如果不是按照索引列的顺序进行查找，则无法使用索引。</p>
<p>InnoDB 的 B+Tree 索引分为主索引和辅助索引。</p>
<p>主索引的叶子节点 data 域记录着完整的数据记录，这种索引方式被称为聚簇索引。因为无法把数据行存放在两个不同的地方，所以一个表只能有一个聚簇索引。</p>
<p><img src="https://github.com/CyC2018/CS-Notes/raw/master/pics/c28c6fbc-2bc1-47d9-9b2e-cf3d4034f877.jpg" alt=""></p>
<p>辅助索引的叶子节点的 data 域记录着主键的值，因此在使用辅助索引进行查找时，需要先查找到主键值，然后再到主索引中进行查找。</p>
<p><img src="https://github.com/CyC2018/CS-Notes/raw/master/pics/7ab8ca28-2a41-4adf-9502-cc0a21e63b51.jpg" alt=""></p>
<h3 id="2-哈希索引"><a href="#2-哈希索引" class="headerlink" title="2. 哈希索引"></a>2. 哈希索引</h3><p>哈希索引能以 O(1) 时间进行查找，但是失去了有序性，它具有以下限制：</p>
<ul>
<li>无法用于排序与分组；</li>
<li>只支持精确查找，无法用于部分查找和范围查找。</li>
</ul>
<p>InnoDB 存储引擎有一个特殊的功能叫“自适应哈希索引”，当某个索引值被使用的非常频繁时，会在 B+Tree 索引之上再创建一个哈希索引，这样就让 B+Tree 索引具有哈希索引的一些优点，比如快速的哈希查找。</p>
<h3 id="3-全文索引"><a href="#3-全文索引" class="headerlink" title="3. 全文索引"></a>3. 全文索引</h3><p>MyISAM 存储引擎支持全文索引，用于查找文本中的关键词，而不是直接比较是否相等。查找条件使用 MATCH AGAINST，而不是普通的 WHERE。</p>
<p>全文索引一般使用倒排索引实现，它记录着关键词到其所在文档的映射。</p>
<p>InnoDB 存储引擎在 MySQL 5.6.4 版本中也开始支持全文索引。</p>
<h3 id="4-空间数据索引"><a href="#4-空间数据索引" class="headerlink" title="4. 空间数据索引"></a>4. 空间数据索引</h3><p>MyISAM 存储引擎支持空间数据索引（R-Tree），可以用于地理数据存储。空间数据索引会从所有维度来索引数据，可以有效地使用任意维度来进行组合查询。</p>
<p>必须使用 GIS 相关的函数来维护数据。</p>
<h2 id="索引优化"><a href="#索引优化" class="headerlink" title="索引优化"></a>索引优化</h2><h3 id="1-独立的列"><a href="#1-独立的列" class="headerlink" title="1. 独立的列"></a>1. 独立的列</h3><p>在进行查询时，索引列不能是表达式的一部分，也不能是函数的参数，否则无法使用索引。</p>
<p>例如下面的查询不能使用 actor_id 列的索引：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SELECT actor_id FROM sakila.actor WHERE actor_id + 1 = 5;</span><br></pre></td></tr></table></figure>
<h3 id="2-多列索引"><a href="#2-多列索引" class="headerlink" title="2. 多列索引"></a>2. 多列索引</h3><p>在需要使用多个列作为条件进行查询时，使用多列索引比使用多个单列索引性能更好。例如下面的语句中，最好把 actor_id 和 film_id 设置为多列索引。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">SELECT film_id, actor_ id FROM sakila.film_actor</span><br><span class="line">WHERE actor_id = 1 AND film_id = 1;</span><br></pre></td></tr></table></figure>
<h3 id="3-索引列的顺序"><a href="#3-索引列的顺序" class="headerlink" title="3. 索引列的顺序"></a>3. 索引列的顺序</h3><p>让选择性最强的索引列放在前面，索引的选择性是指：不重复的索引值和记录总数的比值。最大值为 1，此时每个记录都有唯一的索引与其对应。选择性越高，查询效率也越高。</p>
<p>例如下面显示的结果中 customer_id 的选择性比 staff_id 更高，因此最好把 customer_id 列放在多列索引的前面。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">SELECT COUNT(DISTINCT staff_id)/COUNT(*) AS staff_id_selectivity,</span><br><span class="line">COUNT(DISTINCT customer_id)/COUNT(*) AS customer_id_selectivity,</span><br><span class="line">COUNT(*)</span><br><span class="line">FROM payment;</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">   staff_id_selectivity: 0.0001</span><br><span class="line">customer_id_selectivity: 0.0373</span><br><span class="line">               COUNT(*): 16049</span><br></pre></td></tr></table></figure>
<h3 id="4-前缀索引"><a href="#4-前缀索引" class="headerlink" title="4. 前缀索引"></a>4. 前缀索引</h3><p>对于 BLOB、TEXT 和 VARCHAR 类型的列，必须使用前缀索引，只索引开始的部分字符。</p>
<p>对于前缀长度的选取需要根据索引选择性来确定。</p>
<h3 id="5-覆盖索引"><a href="#5-覆盖索引" class="headerlink" title="5. 覆盖索引"></a>5. 覆盖索引</h3><p>索引包含所有需要查询的字段的值。</p>
<p>具有以下优点：</p>
<ul>
<li>索引通常远小于数据行的大小，只读取索引能大大减少数据访问量。</li>
<li>一些存储引擎（例如 MyISAM）在内存中只缓存索引，而数据依赖于操作系统来缓存。因此，只访问索引可以不使用系统调用（通常比较费时）。</li>
<li>对于 InnoDB 引擎，若辅助索引能够覆盖查询，则无需访问主索引。</li>
</ul>
<h2 id="索引的优点"><a href="#索引的优点" class="headerlink" title="索引的优点"></a>索引的优点</h2><ul>
<li><p>大大减少了服务器需要扫描的数据行数。</p>
</li>
<li><p>帮助服务器避免进行排序和分组，也就不需要创建临时表（B+Tree 索引是有序的，可以用于 ORDER BY 和 GROUP BY 操作。临时表主要是在排序和分组过程中创建，因为不需要排序和分组，也就不需要创建临时表）。</p>
</li>
<li><p>将随机 I/O 变为顺序 I/O（B+Tree 索引是有序的，也就将相邻的数据都存储在一起）。</p>
</li>
</ul>
<h2 id="索引的使用场景"><a href="#索引的使用场景" class="headerlink" title="索引的使用场景"></a>索引的使用场景</h2><ul>
<li>对于非常小的表、大部分情况下简单的全表扫描比建立索引更高效。</li>
<li>对于中到大型的表，索引就非常有效。</li>
<li>但是对于特大型的表，建立和维护索引的代价将会随之增长。这种情况下，需要用到一种技术可以直接区分出需要查询的一组数据，而不是一条记录一条记录地匹配，例如可以使用分区技术。</li>
</ul>
<h1 id="二、查询性能优化"><a href="#二、查询性能优化" class="headerlink" title="二、查询性能优化"></a>二、查询性能优化</h1><h2 id="使用-Explain-进行分析"><a href="#使用-Explain-进行分析" class="headerlink" title="使用 Explain 进行分析"></a>使用 Explain 进行分析</h2><p>Explain 用来分析 SELECT 查询语句，开发人员可以通过分析 Explain 结果来优化查询语句。</p>
<p>比较重要的字段有：</p>
<ul>
<li>select_type : 查询类型，有简单查询、联合查询、子查询等</li>
<li>key : 使用的索引</li>
<li>rows : 扫描的行数</li>
</ul>
<h2 id="优化数据访问"><a href="#优化数据访问" class="headerlink" title="优化数据访问"></a>优化数据访问</h2><h3 id="1-减少请求的数据量"><a href="#1-减少请求的数据量" class="headerlink" title="1. 减少请求的数据量"></a>1. 减少请求的数据量</h3><ul>
<li>只返回必要的列：最好不要使用 SELECT * 语句。</li>
<li>只返回必要的行：使用 LIMIT 语句来限制返回的数据。</li>
<li>缓存重复查询的数据：使用缓存可以避免在数据库中进行查询，特别在要查询的数据经常被重复查询时，缓存带来的查询性能提升将会是非常明显的。</li>
</ul>
<h3 id="2-减少服务器端扫描的行数"><a href="#2-减少服务器端扫描的行数" class="headerlink" title="2. 减少服务器端扫描的行数"></a>2. 减少服务器端扫描的行数</h3><p>最有效的方式是使用索引来覆盖查询。</p>
<h2 id="重构查询方式"><a href="#重构查询方式" class="headerlink" title="重构查询方式"></a>重构查询方式</h2><h3 id="1-切分大查询"><a href="#1-切分大查询" class="headerlink" title="1. 切分大查询"></a>1. 切分大查询</h3><p>一个大查询如果一次性执行的话，可能一次锁住很多数据、占满整个事务日志、耗尽系统资源、阻塞很多小的但重要的查询。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">DELETE FROM messages WHERE create &lt; DATE_SUB(NOW(), INTERVAL 3 MONTH);</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">rows_affected = 0</span><br><span class="line">do &#123;</span><br><span class="line">    rows_affected = do_query(</span><br><span class="line">    &quot;DELETE FROM messages WHERE create  &lt; DATE_SUB(NOW(), INTERVAL 3 MONTH) LIMIT 10000&quot;)</span><br><span class="line">&#125; while rows_affected &gt; 0</span><br></pre></td></tr></table></figure>
<h3 id="2-分解大连接查询"><a href="#2-分解大连接查询" class="headerlink" title="2. 分解大连接查询"></a>2. 分解大连接查询</h3><p>将一个大连接查询分解成对每一个表进行一次单表查询，然后将结果在应用程序中进行关联，这样做的好处有：</p>
<ul>
<li>让缓存更高效。对于连接查询，如果其中一个表发生变化，那么整个查询缓存就无法使用。而分解后的多个查询，即使其中一个表发生变化，对其它表的查询缓存依然可以使用。</li>
<li>分解成多个单表查询，这些单表查询的缓存结果更可能被其它查询使用到，从而减少冗余记录的查询。</li>
<li>减少锁竞争；</li>
<li>在应用层进行连接，可以更容易对数据库进行拆分，从而更容易做到高性能和可伸缩。</li>
<li>查询本身效率也可能会有所提升。例如下面的例子中，使用 IN() 代替连接查询，可以让 MySQL 按照 ID 顺序进行查询，这可能比随机的连接要更高效。</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">SELECT * FROM tag</span><br><span class="line">JOIN tag_post ON tag_post.tag_id=tag.id</span><br><span class="line">JOIN post ON tag_post.post_id=post.id</span><br><span class="line">WHERE tag.tag=&apos;mysql&apos;;</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">SELECT * FROM tag WHERE tag=&apos;mysql&apos;;</span><br><span class="line">SELECT * FROM tag_post WHERE tag_id=1234;</span><br><span class="line">SELECT * FROM post WHERE post.id IN (123,456,567,9098,8904);</span><br></pre></td></tr></table></figure>
<h1 id="三、存储引擎"><a href="#三、存储引擎" class="headerlink" title="三、存储引擎"></a>三、存储引擎</h1><h2 id="InnoDB"><a href="#InnoDB" class="headerlink" title="InnoDB"></a>InnoDB</h2><p>是 MySQL 默认的事务型存储引擎，只有在需要它不支持的特性时，才考虑使用其它存储引擎。</p>
<p>实现了四个标准的隔离级别，默认级别是可重复读（REPEATABLE READ）。在可重复读隔离级别下，通过多版本并发控制（MVCC）+ 间隙锁（Next-Key Locking）防止幻影读。</p>
<p>主索引是聚簇索引，在索引中保存了数据，从而避免直接读取磁盘，因此对查询性能有很大的提升。</p>
<p>内部做了很多优化，包括从磁盘读取数据时采用的可预测性读、能够加快读操作并且自动创建的自适应哈希索引、能够加速插入操作的插入缓冲区等。</p>
<p>支持真正的在线热备份。其它存储引擎不支持在线热备份，要获取一致性视图需要停止对所有表的写入，而在读写混合场景中，停止写入可能也意味着停止读取。</p>
<h2 id="MyISAM"><a href="#MyISAM" class="headerlink" title="MyISAM"></a>MyISAM</h2><p>设计简单，数据以紧密格式存储。对于只读数据，或者表比较小、可以容忍修复操作，则依然可以使用它。</p>
<p>提供了大量的特性，包括压缩表、空间数据索引等。</p>
<p>不支持事务。</p>
<p>不支持行级锁，只能对整张表加锁，读取时会对需要读到的所有表加共享锁，写入时则对表加排它锁。但在表有读取操作的同时，也可以往表中插入新的记录，这被称为并发插入（CONCURRENT INSERT）。</p>
<p>可以手工或者自动执行检查和修复操作，但是和事务恢复以及崩溃恢复不同，可能导致一些数据丢失，而且修复操作是非常慢的。</p>
<p>如果指定了 DELAY_KEY_WRITE 选项，在每次修改执行完成时，不会立即将修改的索引数据写入磁盘，而是会写到内存中的键缓冲区，只有在清理键缓冲区或者关闭表的时候才会将对应的索引块写入磁盘。这种方式可以极大的提升写入性能，但是在数据库或者主机崩溃时会造成索引损坏，需要执行修复操作。</p>
<h2 id="比较"><a href="#比较" class="headerlink" title="比较"></a>比较</h2><ul>
<li><p>事务：InnoDB 是事务型的，可以使用 Commit 和 Rollback 语句。</p>
</li>
<li><p>并发：MyISAM 只支持表级锁，而 InnoDB 还支持行级锁。</p>
</li>
<li><p>外键：InnoDB 支持外键。</p>
</li>
<li><p>备份：InnoDB 支持在线热备份。</p>
</li>
<li><p>崩溃恢复：MyISAM 崩溃后发生损坏的概率比 InnoDB 高很多，而且恢复的速度也更慢。</p>
</li>
<li><p>其它特性：MyISAM 支持压缩表和空间数据索引。</p>
</li>
</ul>
<h1 id="四、数据类型"><a href="#四、数据类型" class="headerlink" title="四、数据类型"></a>四、数据类型</h1><h2 id="整型"><a href="#整型" class="headerlink" title="整型"></a>整型</h2><p>TINYINT, SMALLINT, MEDIUMINT, INT, BIGINT 分别使用 8, 16, 24, 32, 64 位存储空间，一般情况下越小的列越好。</p>
<p>INT(11) 中的数字只是规定了交互工具显示字符的个数，对于存储和计算来说是没有意义的。</p>
<h2 id="浮点数"><a href="#浮点数" class="headerlink" title="浮点数"></a>浮点数</h2><p>FLOAT 和 DOUBLE 为浮点类型，DECIMAL 为高精度小数类型。CPU 原生支持浮点运算，但是不支持 DECIMAl 类型的计算，因此 DECIMAL 的计算比浮点类型需要更高的代价。</p>
<p>FLOAT、DOUBLE 和 DECIMAL 都可以指定列宽，例如 DECIMAL(18, 9) 表示总共 18 位，取 9 位存储小数部分，剩下 9 位存储整数部分。</p>
<h2 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h2><p>主要有 CHAR 和 VARCHAR 两种类型，一种是定长的，一种是变长的。</p>
<p>VARCHAR 这种变长类型能够节省空间，因为只需要存储必要的内容。但是在执行 UPDATE 时可能会使行变得比原来长，当超出一个页所能容纳的大小时，就要执行额外的操作。MyISAM 会将行拆成不同的片段存储，而 InnoDB 则需要分裂页来使行放进页内。</p>
<p>VARCHAR 会保留字符串末尾的空格，而 CHAR 会删除。</p>
<h2 id="时间和日期"><a href="#时间和日期" class="headerlink" title="时间和日期"></a>时间和日期</h2><p>MySQL 提供了两种相似的日期时间类型：DATETIME 和 TIMESTAMP。</p>
<h3 id="1-DATETIME"><a href="#1-DATETIME" class="headerlink" title="1. DATETIME"></a>1. DATETIME</h3><p>能够保存从 1001 年到 9999 年的日期和时间，精度为秒，使用 8 字节的存储空间。</p>
<p>它与时区无关。</p>
<p>默认情况下，MySQL 以一种可排序的、无歧义的格式显示 DATETIME 值，例如“2008-01-16 22:37:08”，这是 ANSI 标准定义的日期和时间表示方法。</p>
<h3 id="2-TIMESTAMP"><a href="#2-TIMESTAMP" class="headerlink" title="2. TIMESTAMP"></a>2. TIMESTAMP</h3><p>和 UNIX 时间戳相同，保存从 1970 年 1 月 1 日午夜（格林威治时间）以来的秒数，使用 4 个字节，只能表示从 1970 年 到 2038 年。</p>
<p>它和时区有关，也就是说一个时间戳在不同的时区所代表的具体时间是不同的。</p>
<p>MySQL 提供了 FROM_UNIXTIME() 函数把 UNIX 时间戳转换为日期，并提供了 UNIX_TIMESTAMP() 函数把日期转换为 UNIX 时间戳。</p>
<p>默认情况下，如果插入时没有指定 TIMESTAMP 列的值，会将这个值设置为当前时间。</p>
<p>应该尽量使用 TIMESTAMP，因为它比 DATETIME 空间效率更高。</p>
<h1 id="五、切分"><a href="#五、切分" class="headerlink" title="五、切分"></a>五、切分</h1><h2 id="水平切分"><a href="#水平切分" class="headerlink" title="水平切分"></a>水平切分</h2><p>水平切分又称为 Sharding，它是将同一个表中的记录拆分到多个结构相同的表中。</p>
<p>当一个表的数据不断增多时，Sharding 是必然的选择，它可以将数据分布到集群的不同节点上，从而缓存单个数据库的压力。</p>
<p><img src="https://github.com/CyC2018/CS-Notes/raw/master/pics/63c2909f-0c5f-496f-9fe5-ee9176b31aba.jpg" alt=""></p>
<h2 id="垂直切分"><a href="#垂直切分" class="headerlink" title="垂直切分"></a>垂直切分</h2><p><img src="https://github.com/CyC2018/CS-Notes/raw/master/pics/e130e5b8-b19a-4f1e-b860-223040525cf6.jpg" alt=""></p>
<p>垂直切分是将一张表按列切分成多个表，通常是按照列的关系密集程度进行切分，也可以利用垂直切分将经常被使用的列和不经常被使用的列切分到不同的表中。</p>
<p>在数据库的层面使用垂直切分将按数据库中表的密集程度部署到不同的库中，例如将原来的电商数据库垂直切分成商品数据库、用户数据库等。</p>
<h2 id="Sharding-策略"><a href="#Sharding-策略" class="headerlink" title="Sharding 策略"></a>Sharding 策略</h2><ul>
<li>哈希取模：hash(key) % NUM_DB</li>
<li>范围：可以是 ID 范围也可以是时间范围</li>
<li>映射表：使用单独的一个数据库来存储映射关系</li>
</ul>
<h2 id="Sharding-存在的问题及解决方案"><a href="#Sharding-存在的问题及解决方案" class="headerlink" title="Sharding 存在的问题及解决方案"></a>Sharding 存在的问题及解决方案</h2><h3 id="1-事务问题"><a href="#1-事务问题" class="headerlink" title="1. 事务问题"></a>1. 事务问题</h3><p>使用分布式事务来解决，比如 XA 接口。</p>
<h3 id="2-链接"><a href="#2-链接" class="headerlink" title="2. 链接"></a>2. 链接</h3><p>可以将原来的 JOIN 分解成多个单表查询，然后在用户程序中进行 JOIN。</p>
<h3 id="3-ID-唯一性"><a href="#3-ID-唯一性" class="headerlink" title="3. ID 唯一性"></a>3. ID 唯一性</h3><ul>
<li>使用全局唯一 ID：GUID</li>
<li>为每个分片指定一个 ID 范围</li>
<li>分布式 ID 生成器 (如 Twitter 的 Snowflake 算法)</li>
</ul>
<p>更多内容请参考：</p>
<ul>
<li><a href="https://medium.com/@jeeyoungk/how-sharding-works-b4dec46b3f6" target="_blank" rel="noopener">How Sharding Works</a></li>
<li><a href="https://tech.meituan.com/dianping_order_db_sharding.html" target="_blank" rel="noopener">大众点评订单系统分库分表实践</a></li>
</ul>
<h1 id="六、复制"><a href="#六、复制" class="headerlink" title="六、复制"></a>六、复制</h1><h2 id="主从复制"><a href="#主从复制" class="headerlink" title="主从复制"></a>主从复制</h2><p>主要涉及三个线程：binlog 线程、I/O 线程和 SQL 线程。</p>
<ul>
<li><strong>binlog 线程</strong> ：负责将主服务器上的数据更改写入二进制日志中。</li>
<li><strong>I/O 线程</strong> ：负责从主服务器上读取二进制日志，并写入从服务器的中继日志中。</li>
<li><strong>SQL 线程</strong> ：负责读取中继日志并重放其中的 SQL 语句。</li>
</ul>
<p><img src="https://github.com/CyC2018/CS-Notes/raw/master/pics/master-slave.png" alt=""></p>
<h2 id="读写分离"><a href="#读写分离" class="headerlink" title="读写分离"></a>读写分离</h2><p>主服务器处理写操作以及实时性要求比较高的读操作，而从服务器处理读操作。</p>
<p>读写分离能提高性能的原因在于：</p>
<ul>
<li>主从服务器负责各自的读和写，极大程度缓解了锁的争用；</li>
<li>从服务器可以使用 MyISAM，提升查询性能以及节约系统开销；</li>
<li>增加冗余，提高可用性。</li>
</ul>
<p>读写分离常用代理方式来实现，代理服务器接收应用层传来的读写请求，然后决定转发到哪个服务器。</p>
<p><img src="https://github.com/CyC2018/CS-Notes/raw/master/pics/master-slave-proxy.png" alt=""></p>
<h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><ul>
<li>BaronScbwartz, PeterZaitsev, VadimTkacbenko, 等. 高性能 MySQL[M]. 电子工业出版社, 2013.</li>
<li>姜承尧. MySQL 技术内幕: InnoDB 存储引擎 [M]. 机械工业出版社, 2011.</li>
<li><a href="https://www.jfox.info/20-tiao-mysql-xing-nen-you-hua-de-zui-jia-jing-yan.html" target="_blank" rel="noopener">20+ 条 MySQL 性能优化的最佳经验</a></li>
<li><a href="http://blog.720ui.com/2017/mysql_core_09_multi_db_table2/" title="服务端指南 数据存储篇 | MySQL（09） 分库与分表带来的分布式困境与应对之策" target="_blank" rel="noopener">服务端指南 数据存储篇 | MySQL（09） 分库与分表带来的分布式困境与应对之策</a></li>
<li><a href="https://stackoverflow.com/questions/788829/how-to-create-unique-row-id-in-sharded-databases" target="_blank" rel="noopener">How to create unique row ID in sharded databases?</a></li>
<li><a href="http://geekswithblogs.net/shaunxu/archive/2012/01/07/sql-azure-federation-ndash-introduction.aspx" title="Title of this entry." target="_blank" rel="noopener">SQL Azure Federation – Introduction</a></li>
<li><a href="http://blog.codinglabs.org/articles/theory-of-mysql-index.html" target="_blank" rel="noopener">MySQL 索引背后的数据结构及算法原理</a></li>
<li><a href="https://segmentfault.com/a/1190000008131735" target="_blank" rel="noopener">MySQL 性能优化神器 Explain 使用分析</a></li>
</ul>

        </div>
    

</div>
            
                
<div class="post">

    <div class="post-header index">
        <h1 class="title">
            <a href="/2018/08/16/SQL/">
                SQL
            </a>
        </h1>
        <div class="post-info">
            
                <span class="date">2018-08-16</span>
            
            
            
        </div>
    </div>

    
        <div class="content">
            <h1 id="一、基础"><a href="#一、基础" class="headerlink" title="一、基础"></a>一、基础</h1><p>模式定义了数据如何存储、存储什么样的数据以及数据如何分解等信息，数据库和表都有模式。</p>
<p>主键的值不允许修改，也不允许复用（不能使用已经删除的主键值赋给新数据行的主键）。</p>
<p>SQL（Structured Query Language)，标准 SQL 由 ANSI 标准委员会管理，从而称为 ANSI SQL。各个 DBMS 都有自己的实现，如 PL/SQL、Transact-SQL 等。</p>
<p>SQL 语句不区分大小写，但是数据库表名、列名和值是否区分依赖于具体的 DBMS 以及配置。</p>
<p>SQL 支持以下三种注释：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"># 注释</span><br><span class="line">SELECT *</span><br><span class="line">FROM mytable; -- 注释</span><br><span class="line">/* 注释1</span><br><span class="line">   注释2 */</span><br></pre></td></tr></table></figure>
<p>数据库创建与使用：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">CREATE DATABASE test;</span><br><span class="line">USE test;</span><br></pre></td></tr></table></figure>
<h1 id="二、创建表"><a href="#二、创建表" class="headerlink" title="二、创建表"></a>二、创建表</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">CREATE TABLE mytable (</span><br><span class="line">  id INT NOT NULL AUTO_INCREMENT,</span><br><span class="line">  col1 INT NOT NULL DEFAULT 1,</span><br><span class="line">  col2 VARCHAR(45) NULL,</span><br><span class="line">  col3 DATE NULL,</span><br><span class="line">  PRIMARY KEY (`id`));</span><br></pre></td></tr></table></figure>
<h1 id="三、修改表"><a href="#三、修改表" class="headerlink" title="三、修改表"></a>三、修改表</h1><p>添加列</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ALTER TABLE mytable</span><br><span class="line">ADD col CHAR(20);</span><br></pre></td></tr></table></figure>
<p>删除列</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ALTER TABLE mytable</span><br><span class="line">DROP COLUMN col;</span><br></pre></td></tr></table></figure>
<p>删除表</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">DROP TABLE mytable;</span><br></pre></td></tr></table></figure>
<h1 id="四、插入"><a href="#四、插入" class="headerlink" title="四、插入"></a>四、插入</h1><p>普通插入</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">INSERT INTO mytable(col1, col2)</span><br><span class="line">VALUES(val1, val2);</span><br></pre></td></tr></table></figure>
<p>插入检索出来的数据</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">INSERT INTO mytable1(col1, col2)</span><br><span class="line">SELECT col1, col2</span><br><span class="line">FROM mytable2;</span><br></pre></td></tr></table></figure>
<p>将一个表的内容插入到一个新表</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">CREATE TABLE newtable AS</span><br><span class="line">SELECT * FROM mytable;</span><br></pre></td></tr></table></figure>
<h1 id="五、更新"><a href="#五、更新" class="headerlink" title="五、更新"></a>五、更新</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">UPDATE mytable</span><br><span class="line">SET col = val</span><br><span class="line">WHERE id = 1;</span><br></pre></td></tr></table></figure>
<h1 id="六、删除"><a href="#六、删除" class="headerlink" title="六、删除"></a>六、删除</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">DELETE FROM mytable</span><br><span class="line">WHERE id = 1;</span><br></pre></td></tr></table></figure>
<p><strong>TRUNCATE TABLE</strong> 可以清空表，也就是删除所有行。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">TRUNCATE TABLE mytable;</span><br></pre></td></tr></table></figure>
<p>使用更新和删除操作时一定要用 WHERE 子句，不然会把整张表的数据都破坏。可以先用 SELECT 语句进行测试，防止错误删除。</p>
<h1 id="七、查询"><a href="#七、查询" class="headerlink" title="七、查询"></a>七、查询</h1><h2 id="DISTINCT"><a href="#DISTINCT" class="headerlink" title="DISTINCT"></a>DISTINCT</h2><p>相同值只会出现一次。它作用于所有列，也就是说所有列的值都相同才算相同。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">SELECT DISTINCT col1, col2</span><br><span class="line">FROM mytable;</span><br></pre></td></tr></table></figure>
<h2 id="LIMIT"><a href="#LIMIT" class="headerlink" title="LIMIT"></a>LIMIT</h2><p>限制返回的行数。可以有两个参数，第一个参数为起始行，从 0 开始；第二个参数为返回的总行数。</p>
<p>返回前 5 行：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">SELECT *</span><br><span class="line">FROM mytable</span><br><span class="line">LIMIT 5;</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">SELECT *</span><br><span class="line">FROM mytable</span><br><span class="line">LIMIT 0, 5;</span><br></pre></td></tr></table></figure>
<p>返回第 3 ~ 5 行：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">SELECT *</span><br><span class="line">FROM mytable</span><br><span class="line">LIMIT 2, 3;</span><br></pre></td></tr></table></figure>
<h1 id="八、排序"><a href="#八、排序" class="headerlink" title="八、排序"></a>八、排序</h1><ul>
<li><strong>ASC</strong> ：升序（默认）</li>
<li><strong>DESC</strong> ：降序</li>
</ul>
<p>可以按多个列进行排序，并且为每个列指定不同的排序方式：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">SELECT *</span><br><span class="line">FROM mytable</span><br><span class="line">ORDER BY col1 DESC, col2 ASC;</span><br></pre></td></tr></table></figure>
<h1 id="九、过滤"><a href="#九、过滤" class="headerlink" title="九、过滤"></a>九、过滤</h1><p>不进行过滤的数据非常大，导致通过网络传输了多余的数据，从而浪费了网络带宽。因此尽量使用 SQL 语句来过滤不必要的数据，而不是传输所有的数据到客户端中然后由客户端进行过滤。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">SELECT *</span><br><span class="line">FROM mytable</span><br><span class="line">WHERE col IS NULL;</span><br></pre></td></tr></table></figure>
<p>下表显示了 WHERE 子句可用的操作符</p>
<table>
<thead>
<tr>
<th style="text-align:center">操作符</th>
<th style="text-align:center">说明</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">=</td>
<td style="text-align:center">等于</td>
</tr>
<tr>
<td style="text-align:center">&lt;</td>
<td style="text-align:center">小于</td>
</tr>
<tr>
<td style="text-align:center">&gt;</td>
<td style="text-align:center">大于</td>
</tr>
<tr>
<td style="text-align:center">&lt;&gt; !=</td>
<td style="text-align:center">不等于</td>
</tr>
<tr>
<td style="text-align:center">&lt;= !&gt;</td>
<td style="text-align:center">小于等于</td>
</tr>
<tr>
<td style="text-align:center">&gt;= !&lt;</td>
<td style="text-align:center">大于等于</td>
</tr>
<tr>
<td style="text-align:center">BETWEEN</td>
<td style="text-align:center">在两个值之间</td>
</tr>
<tr>
<td style="text-align:center">IS NULL</td>
<td style="text-align:center">为 NULL 值</td>
</tr>
</tbody>
</table>
<p>应该注意到，NULL 与 0、空字符串都不同。</p>
<p><strong>AND 和 OR</strong> 用于连接多个过滤条件。优先处理 AND，当一个过滤表达式涉及到多个 AND 和 OR 时，可以使用 () 来决定优先级，使得优先级关系更清晰。</p>
<p><strong>IN</strong> 操作符用于匹配一组值，其后也可以接一个 SELECT 子句，从而匹配子查询得到的一组值。</p>
<p><strong>NOT</strong> 操作符用于否定一个条件。</p>
<h1 id="十、通配符"><a href="#十、通配符" class="headerlink" title="十、通配符"></a>十、通配符</h1><p>通配符也是用在过滤语句中，但它只能用于文本字段。</p>
<ul>
<li><p><strong>%</strong> 匹配 &gt;=0 个任意字符；</p>
</li>
<li><p><strong>_</strong> 匹配 ==1 个任意字符；</p>
</li>
<li><p><strong>[ ]</strong> 可以匹配集合内的字符，例如 [ab] 将匹配字符 a 或者 b。用脱字符 ^ 可以对其进行否定，也就是不匹配集合内的字符。</p>
</li>
</ul>
<p>使用 Like 来进行通配符匹配。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">SELECT *</span><br><span class="line">FROM mytable</span><br><span class="line">WHERE col LIKE &apos;[^AB]%&apos;; -- 不以 A 和 B 开头的任意文本</span><br></pre></td></tr></table></figure>
<p>不要滥用通配符，通配符位于开头处匹配会非常慢。</p>
<h1 id="十一、计算字段"><a href="#十一、计算字段" class="headerlink" title="十一、计算字段"></a>十一、计算字段</h1><p>在数据库服务器上完成数据的转换和格式化的工作往往比客户端上快得多，并且转换和格式化后的数据量更少的话可以减少网络通信量。</p>
<p>计算字段通常需要使用 <strong>AS</strong> 来取别名，否则输出的时候字段名为计算表达式。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">SELECT col1 * col2 AS alias</span><br><span class="line">FROM mytable;</span><br></pre></td></tr></table></figure>
<p><strong>CONCAT()</strong> 用于连接两个字段。许多数据库会使用空格把一个值填充为列宽，因此连接的结果会出现一些不必要的空格，使用 <strong>TRIM()</strong> 可以去除首尾空格。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">SELECT CONCAT(TRIM(col1), &apos;(&apos;, TRIM(col2), &apos;)&apos;) AS concat_col</span><br><span class="line">FROM mytable;</span><br></pre></td></tr></table></figure>
<h1 id="十二、函数"><a href="#十二、函数" class="headerlink" title="十二、函数"></a>十二、函数</h1><p>各个 DBMS 的函数都是不相同的，因此不可移植，以下主要是 MySQL 的函数。</p>
<h2 id="汇总"><a href="#汇总" class="headerlink" title="汇总"></a>汇总</h2><table>
<thead>
<tr>
<th style="text-align:center">函 数</th>
<th style="text-align:center">说 明</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">AVG()</td>
<td style="text-align:center">返回某列的平均值</td>
</tr>
<tr>
<td style="text-align:center">COUNT()</td>
<td style="text-align:center">返回某列的行数</td>
</tr>
<tr>
<td style="text-align:center">MAX()</td>
<td style="text-align:center">返回某列的最大值</td>
</tr>
<tr>
<td style="text-align:center">MIN()</td>
<td style="text-align:center">返回某列的最小值</td>
</tr>
<tr>
<td style="text-align:center">SUM()</td>
<td style="text-align:center">返回某列值之和</td>
</tr>
</tbody>
</table>
<p>AVG() 会忽略 NULL 行。</p>
<p>使用 DISTINCT 可以让汇总函数值汇总不同的值。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">SELECT AVG(DISTINCT col1) AS avg_col</span><br><span class="line">FROM mytable;</span><br></pre></td></tr></table></figure>
<h2 id="文本处理"><a href="#文本处理" class="headerlink" title="文本处理"></a>文本处理</h2><table>
<thead>
<tr>
<th style="text-align:center">函数</th>
<th style="text-align:center">说明</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">LEFT()</td>
<td style="text-align:center">左边的字符</td>
</tr>
<tr>
<td style="text-align:center">RIGHT()</td>
<td style="text-align:center">右边的字符</td>
</tr>
<tr>
<td style="text-align:center">LOWER()</td>
<td style="text-align:center">转换为小写字符</td>
</tr>
<tr>
<td style="text-align:center">UPPER()</td>
<td style="text-align:center">转换为大写字符</td>
</tr>
<tr>
<td style="text-align:center">LTRIM()</td>
<td style="text-align:center">去除左边的空格</td>
</tr>
<tr>
<td style="text-align:center">RTRIM()</td>
<td style="text-align:center">去除右边的空格</td>
</tr>
<tr>
<td style="text-align:center">LENGTH()</td>
<td style="text-align:center">长度</td>
</tr>
<tr>
<td style="text-align:center">SOUNDEX()</td>
<td style="text-align:center">转换为语音值</td>
</tr>
</tbody>
</table>
<p>其中， <strong>SOUNDEX()</strong> 可以将一个字符串转换为描述其语音表示的字母数字模式。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">SELECT *</span><br><span class="line">FROM mytable</span><br><span class="line">WHERE SOUNDEX(col1) = SOUNDEX(&apos;apple&apos;)</span><br></pre></td></tr></table></figure>
<h2 id="日期和时间处理"><a href="#日期和时间处理" class="headerlink" title="日期和时间处理"></a>日期和时间处理</h2><ul>
<li>日期格式：YYYY-MM-DD</li>
<li>时间格式：HH:MM:SS</li>
</ul>
<table>
<thead>
<tr>
<th style="text-align:center">函 数</th>
<th style="text-align:center">说 明</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">AddDate()</td>
<td style="text-align:center">增加一个日期（天、周等）</td>
</tr>
<tr>
<td style="text-align:center">AddTime()</td>
<td style="text-align:center">增加一个时间（时、分等）</td>
</tr>
<tr>
<td style="text-align:center">CurDate()</td>
<td style="text-align:center">返回当前日期</td>
</tr>
<tr>
<td style="text-align:center">CurTime()</td>
<td style="text-align:center">返回当前时间</td>
</tr>
<tr>
<td style="text-align:center">Date()</td>
<td style="text-align:center">返回日期时间的日期部分</td>
</tr>
<tr>
<td style="text-align:center">DateDiff()</td>
<td style="text-align:center">计算两个日期之差</td>
</tr>
<tr>
<td style="text-align:center">Date_Add()</td>
<td style="text-align:center">高度灵活的日期运算函数</td>
</tr>
<tr>
<td style="text-align:center">Date_Format()</td>
<td style="text-align:center">返回一个格式化的日期或时间串</td>
</tr>
<tr>
<td style="text-align:center">Day()</td>
<td style="text-align:center">返回一个日期的天数部分</td>
</tr>
<tr>
<td style="text-align:center">DayOfWeek()</td>
<td style="text-align:center">对于一个日期，返回对应的星期几</td>
</tr>
<tr>
<td style="text-align:center">Hour()</td>
<td style="text-align:center">返回一个时间的小时部分</td>
</tr>
<tr>
<td style="text-align:center">Minute()</td>
<td style="text-align:center">返回一个时间的分钟部分</td>
</tr>
<tr>
<td style="text-align:center">Month()</td>
<td style="text-align:center">返回一个日期的月份部分</td>
</tr>
<tr>
<td style="text-align:center">Now()</td>
<td style="text-align:center">返回当前日期和时间</td>
</tr>
<tr>
<td style="text-align:center">Second()</td>
<td style="text-align:center">返回一个时间的秒部分</td>
</tr>
<tr>
<td style="text-align:center">Time()</td>
<td style="text-align:center">返回一个日期时间的时间部分</td>
</tr>
<tr>
<td style="text-align:center">Year()</td>
<td style="text-align:center">返回一个日期的年份部分</td>
</tr>
</tbody>
</table>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; SELECT NOW();</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">2018-4-14 20:25:11</span><br></pre></td></tr></table></figure>
<h2 id="数值处理"><a href="#数值处理" class="headerlink" title="数值处理"></a>数值处理</h2><table>
<thead>
<tr>
<th style="text-align:center">函数</th>
<th style="text-align:center">说明</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">SIN()</td>
<td style="text-align:center">正弦</td>
</tr>
<tr>
<td style="text-align:center">COS()</td>
<td style="text-align:center">余弦</td>
</tr>
<tr>
<td style="text-align:center">TAN()</td>
<td style="text-align:center">正切</td>
</tr>
<tr>
<td style="text-align:center">ABS()</td>
<td style="text-align:center">绝对值</td>
</tr>
<tr>
<td style="text-align:center">SQRT()</td>
<td style="text-align:center">平方根</td>
</tr>
<tr>
<td style="text-align:center">MOD()</td>
<td style="text-align:center">余数</td>
</tr>
<tr>
<td style="text-align:center">EXP()</td>
<td style="text-align:center">指数</td>
</tr>
<tr>
<td style="text-align:center">PI()</td>
<td style="text-align:center">圆周率</td>
</tr>
<tr>
<td style="text-align:center">RAND()</td>
<td style="text-align:center">随机数</td>
</tr>
</tbody>
</table>
<h1 id="十三、分组"><a href="#十三、分组" class="headerlink" title="十三、分组"></a>十三、分组</h1><p>分组就是把具有相同的数据值的行放在同一组中。</p>
<p>可以对同一分组数据使用汇总函数进行处理，例如求分组数据的平均值等。</p>
<p>指定的分组字段除了能按该字段进行分组，也会自动按该字段进行排序。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">SELECT col, COUNT(*) AS num</span><br><span class="line">FROM mytable</span><br><span class="line">GROUP BY col;</span><br></pre></td></tr></table></figure>
<p>GROUP BY 自动按分组字段进行排序，ORDER BY 也可以按汇总字段来进行排序。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">SELECT col, COUNT(*) AS num</span><br><span class="line">FROM mytable</span><br><span class="line">GROUP BY col</span><br><span class="line">ORDER BY num;</span><br></pre></td></tr></table></figure>
<p>WHERE 过滤行，HAVING 过滤分组，行过滤应当先于分组过滤。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">SELECT col, COUNT(*) AS num</span><br><span class="line">FROM mytable</span><br><span class="line">WHERE col &gt; 2</span><br><span class="line">GROUP BY col</span><br><span class="line">HAVING num &gt;= 2;</span><br></pre></td></tr></table></figure>
<p>分组规定：</p>
<ul>
<li>GROUP BY 子句出现在 WHERE 子句之后，ORDER BY 子句之前；</li>
<li>除了汇总字段外，SELECT 语句中的每一字段都必须在 GROUP BY 子句中给出；</li>
<li>NULL 的行会单独分为一组；</li>
<li>大多数 SQL 实现不支持 GROUP BY 列具有可变长度的数据类型。</li>
</ul>
<h1 id="十四、子查询"><a href="#十四、子查询" class="headerlink" title="十四、子查询"></a>十四、子查询</h1><p>子查询中只能返回一个字段的数据。</p>
<p>可以将子查询的结果作为 WHRER 语句的过滤条件：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">SELECT *</span><br><span class="line">FROM mytable1</span><br><span class="line">WHERE col1 IN (SELECT col2</span><br><span class="line">               FROM mytable2);</span><br></pre></td></tr></table></figure>
<p>下面的语句可以检索出客户的订单数量，子查询语句会对第一个查询检索出的每个客户执行一次：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">SELECT cust_name, (SELECT COUNT(*)</span><br><span class="line">                   FROM Orders</span><br><span class="line">                   WHERE Orders.cust_id = Customers.cust_id)</span><br><span class="line">                   AS orders_num</span><br><span class="line">FROM Customers</span><br><span class="line">ORDER BY cust_name;</span><br></pre></td></tr></table></figure>
<h1 id="十五、连接"><a href="#十五、连接" class="headerlink" title="十五、连接"></a>十五、连接</h1><p>连接用于连接多个表，使用 JOIN 关键字，并且条件语句使用 ON 而不是 WHERE。</p>
<p>连接可以替换子查询，并且比子查询的效率一般会更快。</p>
<p>可以用 AS 给列名、计算字段和表名取别名，给表名取别名是为了简化 SQL 语句以及连接相同表。</p>
<h2 id="内连接"><a href="#内连接" class="headerlink" title="内连接"></a>内连接</h2><p>内连接又称等值连接，使用 INNER JOIN 关键字。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">SELECT A.value, B.value</span><br><span class="line">FROM tablea AS A INNER JOIN tableb AS B</span><br><span class="line">ON A.key = B.key;</span><br></pre></td></tr></table></figure>
<p>可以不明确使用 INNER JOIN，而使用普通查询并在 WHERE 中将两个表中要连接的列用等值方法连接起来。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">SELECT A.value, B.value</span><br><span class="line">FROM tablea AS A, tableb AS B</span><br><span class="line">WHERE A.key = B.key;</span><br></pre></td></tr></table></figure>
<p>在没有条件语句的情况下返回笛卡尔积。</p>
<h2 id="自连接"><a href="#自连接" class="headerlink" title="自连接"></a>自连接</h2><p>自连接可以看成内连接的一种，只是连接的表是自身而已。</p>
<p>一张员工表，包含员工姓名和员工所属部门，要找出与 Jim 处在同一部门的所有员工姓名。</p>
<p>子查询版本</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">SELECT name</span><br><span class="line">FROM employee</span><br><span class="line">WHERE department = (</span><br><span class="line">      SELECT department</span><br><span class="line">      FROM employee</span><br><span class="line">      WHERE name = &quot;Jim&quot;);</span><br></pre></td></tr></table></figure>
<p>自连接版本</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">SELECT e1.name</span><br><span class="line">FROM employee AS e1 INNER JOIN employee AS e2</span><br><span class="line">ON e1.department = e2.department</span><br><span class="line">      AND e2.name = &quot;Jim&quot;;</span><br></pre></td></tr></table></figure>
<h2 id="自然连接"><a href="#自然连接" class="headerlink" title="自然连接"></a>自然连接</h2><p>自然连接是把同名列通过等值测试连接起来的，同名列可以有多个。</p>
<p>内连接和自然连接的区别：内连接提供连接的列，而自然连接自动连接所有同名列。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">SELECT A.value, B.value</span><br><span class="line">FROM tablea AS A NATURAL JOIN tableb AS B;</span><br></pre></td></tr></table></figure>
<h2 id="外连接"><a href="#外连接" class="headerlink" title="外连接"></a>外连接</h2><p>外连接保留了没有关联的那些行。分为左外连接，右外连接以及全外连接，左外连接就是保留左表没有关联的行。</p>
<p>检索所有顾客的订单信息，包括还没有订单信息的顾客。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">SELECT Customers.cust_id, Orders.order_num</span><br><span class="line">FROM Customers LEFT OUTER JOIN Orders</span><br><span class="line">ON Customers.cust_id = Orders.cust_id;</span><br></pre></td></tr></table></figure>
<p>customers 表：</p>
<table>
<thead>
<tr>
<th style="text-align:center">cust_id</th>
<th style="text-align:center">cust_name</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">1</td>
<td style="text-align:center">a</td>
</tr>
<tr>
<td style="text-align:center">2</td>
<td style="text-align:center">b</td>
</tr>
<tr>
<td style="text-align:center">3</td>
<td style="text-align:center">c</td>
</tr>
</tbody>
</table>
<p>orders 表：</p>
<table>
<thead>
<tr>
<th style="text-align:center">order_id</th>
<th style="text-align:center">cust_id</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">1</td>
<td style="text-align:center">1</td>
</tr>
<tr>
<td style="text-align:center">2</td>
<td style="text-align:center">1</td>
</tr>
<tr>
<td style="text-align:center">3</td>
<td style="text-align:center">3</td>
</tr>
<tr>
<td style="text-align:center">4</td>
<td style="text-align:center">3</td>
</tr>
</tbody>
</table>
<p>结果：</p>
<table>
<thead>
<tr>
<th style="text-align:center">cust_id</th>
<th style="text-align:center">cust_name</th>
<th style="text-align:center">order_id</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">1</td>
<td style="text-align:center">a</td>
<td style="text-align:center">1</td>
</tr>
<tr>
<td style="text-align:center">1</td>
<td style="text-align:center">a</td>
<td style="text-align:center">2</td>
</tr>
<tr>
<td style="text-align:center">3</td>
<td style="text-align:center">c</td>
<td style="text-align:center">3</td>
</tr>
<tr>
<td style="text-align:center">3</td>
<td style="text-align:center">c</td>
<td style="text-align:center">4</td>
</tr>
<tr>
<td style="text-align:center">2</td>
<td style="text-align:center">b</td>
<td style="text-align:center">Null</td>
</tr>
</tbody>
</table>
<h1 id="十六、组合查询"><a href="#十六、组合查询" class="headerlink" title="十六、组合查询"></a>十六、组合查询</h1><p>使用 <strong>UNION</strong> 来组合两个查询，如果第一个查询返回 M 行，第二个查询返回 N 行，那么组合查询的结果一般为 M+N 行。</p>
<p>每个查询必须包含相同的列、表达式和聚集函数。</p>
<p>默认会去除相同行，如果需要保留相同行，使用 UNION ALL。</p>
<p>只能包含一个 ORDER BY 子句，并且必须位于语句的最后。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">SELECT col</span><br><span class="line">FROM mytable</span><br><span class="line">WHERE col = 1</span><br><span class="line">UNION</span><br><span class="line">SELECT col</span><br><span class="line">FROM mytable</span><br><span class="line">WHERE col =2;</span><br></pre></td></tr></table></figure>
<h1 id="十七、视图"><a href="#十七、视图" class="headerlink" title="十七、视图"></a>十七、视图</h1><p>视图是虚拟的表，本身不包含数据，也就不能对其进行索引操作。</p>
<p>对视图的操作和对普通表的操作一样。</p>
<p>视图具有如下好处：</p>
<ul>
<li>简化复杂的 SQL 操作，比如复杂的连接；</li>
<li>只使用实际表的一部分数据；</li>
<li>通过只给用户访问视图的权限，保证数据的安全性；</li>
<li>更改数据格式和表示。</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">CREATE VIEW myview AS</span><br><span class="line">SELECT Concat(col1, col2) AS concat_col, col3*col4 AS compute_col</span><br><span class="line">FROM mytable</span><br><span class="line">WHERE col5 = val;</span><br></pre></td></tr></table></figure>
<h1 id="十八、存储过程"><a href="#十八、存储过程" class="headerlink" title="十八、存储过程"></a>十八、存储过程</h1><p>存储过程可以看成是对一系列 SQL 操作的批处理。</p>
<p>使用存储过程的好处：</p>
<ul>
<li>代码封装，保证了一定的安全性；</li>
<li>代码复用；</li>
<li>由于是预先编译，因此具有很高的性能。</li>
</ul>
<p>命令行中创建存储过程需要自定义分隔符，因为命令行是以 ; 为结束符，而存储过程中也包含了分号，因此会错误把这部分分号当成是结束符，造成语法错误。</p>
<p>包含 in、out 和 inout 三种参数。</p>
<p>给变量赋值都需要用 select into 语句。</p>
<p>每次只能给一个变量赋值，不支持集合的操作。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">delimiter //</span><br><span class="line"></span><br><span class="line">create procedure myprocedure( out ret int )</span><br><span class="line">    begin</span><br><span class="line">        declare y int;</span><br><span class="line">        select sum(col1)</span><br><span class="line">        from mytable</span><br><span class="line">        into y;</span><br><span class="line">        select y*y into ret;</span><br><span class="line">    end //</span><br><span class="line"></span><br><span class="line">delimiter ;</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">call myprocedure(@ret);</span><br><span class="line">select @ret;</span><br></pre></td></tr></table></figure>
<h1 id="十九、游标"><a href="#十九、游标" class="headerlink" title="十九、游标"></a>十九、游标</h1><p>在存储过程中使用游标可以对一个结果集进行移动遍历。</p>
<p>游标主要用于交互式应用，其中用户需要对数据集中的任意行进行浏览和修改。</p>
<p>使用游标的四个步骤：</p>
<ol>
<li>声明游标，这个过程没有实际检索出数据；</li>
<li>打开游标；</li>
<li>取出数据；</li>
<li>关闭游标；</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">delimiter //</span><br><span class="line">create procedure myprocedure(out ret int)</span><br><span class="line">    begin</span><br><span class="line">        declare done boolean default 0;</span><br><span class="line"></span><br><span class="line">        declare mycursor cursor for</span><br><span class="line">        select col1 from mytable;</span><br><span class="line">        # 定义了一个 continue handler，当 sqlstate &apos;02000&apos; 这个条件出现时，会执行 set done = 1</span><br><span class="line">        declare continue handler for sqlstate &apos;02000&apos; set done = 1;</span><br><span class="line"></span><br><span class="line">        open mycursor;</span><br><span class="line"></span><br><span class="line">        repeat</span><br><span class="line">            fetch mycursor into ret;</span><br><span class="line">            select ret;</span><br><span class="line">        until done end repeat;</span><br><span class="line"></span><br><span class="line">        close mycursor;</span><br><span class="line">    end //</span><br><span class="line"> delimiter ;</span><br></pre></td></tr></table></figure>
<h1 id="二十、触发器"><a href="#二十、触发器" class="headerlink" title="二十、触发器"></a>二十、触发器</h1><p>触发器会在某个表执行以下语句时而自动执行：DELETE、INSERT、UPDATE。</p>
<p>触发器必须指定在语句执行之前还是之后自动执行，之前执行使用 BEFORE 关键字，之后执行使用 AFTER 关键字。BEFORE 用于数据验证和净化，AFTER 用于审计跟踪，将修改记录到另外一张表中。</p>
<p>INSERT 触发器包含一个名为 NEW 的虚拟表。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">CREATE TRIGGER mytrigger AFTER INSERT ON mytable</span><br><span class="line">FOR EACH ROW SELECT NEW.col into @result;</span><br><span class="line"></span><br><span class="line">SELECT @result; -- 获取结果</span><br></pre></td></tr></table></figure>
<p>DELETE 触发器包含一个名为 OLD 的虚拟表，并且是只读的。</p>
<p>UPDATE 触发器包含一个名为 NEW 和一个名为 OLD 的虚拟表，其中 NEW 是可以被修改的，而 OLD 是只读的。</p>
<p>MySQL 不允许在触发器中使用 CALL 语句，也就是不能调用存储过程。</p>
<h1 id="二十一、事务管理"><a href="#二十一、事务管理" class="headerlink" title="二十一、事务管理"></a>二十一、事务管理</h1><p>基本术语：</p>
<ul>
<li>事务（transaction）指一组 SQL 语句；</li>
<li>回退（rollback）指撤销指定 SQL 语句的过程；</li>
<li>提交（commit）指将未存储的 SQL 语句结果写入数据库表；</li>
<li>保留点（savepoint）指事务处理中设置的临时占位符（placeholder），你可以对它发布回退（与回退整个事务处理不同）。</li>
</ul>
<p>不能回退 SELECT 语句，回退 SELECT 语句也没意义；也不能回退 CREATE 和 DROP 语句。</p>
<p>MySQL 的事务提交默认是隐式提交，每执行一条语句就把这条语句当成一个事务然后进行提交。当出现 START TRANSACTION 语句时，会关闭隐式提交；当 COMMIT 或 ROLLBACK 语句执行后，事务会自动关闭，重新恢复隐式提交。</p>
<p>通过设置 autocommit 为 0 可以取消自动提交；autocommit 标记是针对每个连接而不是针对服务器的。</p>
<p>如果没有设置保留点，ROLLBACK 会回退到 START TRANSACTION 语句处；如果设置了保留点，并且在 ROLLBACK 中指定该保留点，则会回退到该保留点。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">START TRANSACTION</span><br><span class="line">// ...</span><br><span class="line">SAVEPOINT delete1</span><br><span class="line">// ...</span><br><span class="line">ROLLBACK TO delete1</span><br><span class="line">// ...</span><br><span class="line">COMMIT</span><br></pre></td></tr></table></figure>
<h1 id="二十二、字符集"><a href="#二十二、字符集" class="headerlink" title="二十二、字符集"></a>二十二、字符集</h1><p>基本术语：</p>
<ul>
<li>字符集为字母和符号的集合；</li>
<li>编码为某个字符集成员的内部表示；</li>
<li>校对字符指定如何比较，主要用于排序和分组。</li>
</ul>
<p>除了给表指定字符集和校对外，也可以给列指定：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">CREATE TABLE mytable</span><br><span class="line">(col VARCHAR(10) CHARACTER SET latin COLLATE latin1_general_ci )</span><br><span class="line">DEFAULT CHARACTER SET hebrew COLLATE hebrew_general_ci;</span><br></pre></td></tr></table></figure>
<p>可以在排序、分组时指定校对：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">SELECT *</span><br><span class="line">FROM mytable</span><br><span class="line">ORDER BY col COLLATE latin1_general_ci;</span><br></pre></td></tr></table></figure>
<h1 id="二十三、权限管理"><a href="#二十三、权限管理" class="headerlink" title="二十三、权限管理"></a>二十三、权限管理</h1><p>MySQL 的账户信息保存在 mysql 这个数据库中。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">USE mysql;</span><br><span class="line">SELECT user FROM user;</span><br></pre></td></tr></table></figure>
<p><strong>创建账户</strong></p>
<p>新创建的账户没有任何权限。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">CREATE USER myuser IDENTIFIED BY &apos;mypassword&apos;;</span><br></pre></td></tr></table></figure>
<p><strong>修改账户名</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">RENAME myuser TO newuser;</span><br></pre></td></tr></table></figure>
<p><strong>删除账户</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">DROP USER myuser;</span><br></pre></td></tr></table></figure>
<p><strong>查看权限</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SHOW GRANTS FOR myuser;</span><br></pre></td></tr></table></figure>
<p><strong>授予权限</strong></p>
<p>账户用 username@host 的形式定义，username@% 使用的是默认主机名。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">GRANT SELECT, INSERT ON mydatabase.* TO myuser;</span><br></pre></td></tr></table></figure>
<p><strong>删除权限</strong></p>
<p>GRANT 和 REVOKE 可在几个层次上控制访问权限：</p>
<ul>
<li>整个服务器，使用 GRANT ALL 和 REVOKE ALL；</li>
<li>整个数据库，使用 ON database.*；</li>
<li>特定的表，使用 ON database.table；</li>
<li>特定的列；</li>
<li>特定的存储过程。</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">REVOKE SELECT, INSERT ON mydatabase.* FROM myuser;</span><br></pre></td></tr></table></figure>
<p><strong>更改密码</strong></p>
<p>必须使用 Password() 函数</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SET PASSWROD FOR myuser = Password(&apos;new_password&apos;);</span><br></pre></td></tr></table></figure>
<h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><ul>
<li>BenForta. SQL 必知必会 [M]. 人民邮电出版社, 2013.</li>
</ul>

        </div>
    

</div>
            
                
<div class="post">

    <div class="post-header index">
        <h1 class="title">
            <a href="/2018/08/16/数据库系统原理/">
                数据库系统原理
            </a>
        </h1>
        <div class="post-info">
            
                <span class="date">2018-08-16</span>
            
            
            
        </div>
    </div>

    
        <div class="content">
            <h1 id="一、事务"><a href="#一、事务" class="headerlink" title="一、事务"></a>一、事务</h1><h2 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h2><p>事务指的是满足 ACID 特性的一组操作，可以通过 Commit 提交一个事务，也可以使用 Rollback 进行回滚。</p>
<p><img src="https://github.com/CyC2018/Interview-Notebook/raw/master/pics/185b9c49-4c13-4241-a848-fbff85c03a64.png" alt=""></p>
<h2 id="ACID"><a href="#ACID" class="headerlink" title="ACID"></a>ACID</h2><h3 id="1-原子性（Atomicity）"><a href="#1-原子性（Atomicity）" class="headerlink" title="1. 原子性（Atomicity）"></a>1. 原子性（Atomicity）</h3><p>事务被视为不可分割的最小单元，事务的所有操作要么全部提交成功，要么全部失败回滚。</p>
<p>回滚可以用日志来实现，日志记录着事务所执行的修改操作，在回滚时反向执行这些修改操作即可。</p>
<h3 id="2-一致性（Consistency）"><a href="#2-一致性（Consistency）" class="headerlink" title="2. 一致性（Consistency）"></a>2. 一致性（Consistency）</h3><p>数据库在事务执行前后都保持一致性状态。</p>
<p>在一致性状态下，所有事务对一个数据的读取结果都是相同的。</p>
<h3 id="3-隔离性（Isolation）"><a href="#3-隔离性（Isolation）" class="headerlink" title="3. 隔离性（Isolation）"></a>3. 隔离性（Isolation）</h3><p>一个事务所做的修改在最终提交以前，对其它事务是不可见的。</p>
<h3 id="4-持久性（Durability）"><a href="#4-持久性（Durability）" class="headerlink" title="4. 持久性（Durability）"></a>4. 持久性（Durability）</h3><p>一旦事务提交，则其所做的修改将会永远保存到数据库中。即使系统发生崩溃，事务执行的结果也不能丢失。</p>
<p>可以通过数据库备份和恢复来实现，在系统发生崩溃时，使用备份的数据库进行数据恢复。</p>
<hr>
<p>事务的 ACID 特性概念简单，但不是很好理解，主要是因为这几个特性不是一种平级关系：</p>
<ul>
<li>只有满足一致性，事务的执行结果才是正确的。</li>
<li>在无并发的情况下，事务串行执行，隔离性一定能够满足。此时只要能满足原子性，就一定能满足一致性。</li>
<li>在并发的情况下，多个事务并发执行，事务不仅要满足原子性，还需要满足隔离性，才能满足一致性。</li>
<li>事务满足持久化是为了能应对数据库崩溃的情况。</li>
</ul>
<p><img src="https://github.com/CyC2018/Interview-Notebook/raw/master/pics/a58e294a-615d-4ea0-9fbf-064a6daec4b2.png" alt=""></p>
<h2 id="AUTOCOMMIT"><a href="#AUTOCOMMIT" class="headerlink" title="AUTOCOMMIT"></a>AUTOCOMMIT</h2><p>MySQL 默认采用自动提交模式。也就是说，如果不显式使用<code>START TRANSACTION</code>语句来开始一个事务，那么每个查询都会被当做一个事务自动提交。</p>
<h1 id="二、并发一致性问题"><a href="#二、并发一致性问题" class="headerlink" title="二、并发一致性问题"></a>二、并发一致性问题</h1><p>在并发环境下，事务的隔离性很难保证，因此会出现很多并发一致性问题。</p>
<h2 id="丢失修改"><a href="#丢失修改" class="headerlink" title="丢失修改"></a>丢失修改</h2><p>T1 和 T2 两个事务都对一个数据进行修改，T1 先修改，T2 随后修改，T2 的修改覆盖了 T1 的修改。</p>
<p><img src="https://github.com/CyC2018/Interview-Notebook/raw/master/pics/88ff46b3-028a-4dbb-a572-1f062b8b96d3.png" alt=""></p>
<h2 id="读脏数据"><a href="#读脏数据" class="headerlink" title="读脏数据"></a>读脏数据</h2><p>T1 修改一个数据，T2 随后读取这个数据。如果 T1 撤销了这次修改，那么 T2 读取的数据是脏数据。</p>
<p><img src="https://github.com/CyC2018/Interview-Notebook/raw/master/pics/dd782132-d830-4c55-9884-cfac0a541b8e.png" alt=""></p>
<h2 id="不可重复读"><a href="#不可重复读" class="headerlink" title="不可重复读"></a>不可重复读</h2><p>T2 读取一个数据，T1 对该数据做了修改。如果 T2 再次读取这个数据，此时读取的结果和第一次读取的结果不同。</p>
<p><img src="https://github.com/CyC2018/Interview-Notebook/raw/master/pics/c8d18ca9-0b09-441a-9a0c-fb063630d708.png" alt=""></p>
<h2 id="幻影读"><a href="#幻影读" class="headerlink" title="幻影读"></a>幻影读</h2><p>T1 读取某个范围的数据，T2 在这个范围内插入新的数据，T1 再次读取这个范围的数据，此时读取的结果和和第一次读取的结果不同。</p>
<p><img src="https://github.com/CyC2018/Interview-Notebook/raw/master/pics/72fe492e-f1cb-4cfc-92f8-412fb3ae6fec.png" alt=""></p>
<hr>
<p>产生并发不一致性问题主要原因是破坏了事务的隔离性，解决方法是通过并发控制来保证隔离性。并发控制可以通过封锁来实现，但是封锁操作需要用户自己控制，相当复杂。数据库管理系统提供了事务的隔离级别，让用户以一种更轻松的方式处理并发一致性问题。</p>
<h1 id="三、封锁"><a href="#三、封锁" class="headerlink" title="三、封锁"></a>三、封锁</h1><h2 id="封锁粒度"><a href="#封锁粒度" class="headerlink" title="封锁粒度"></a>封锁粒度</h2><p>MySQL 中提供了两种封锁粒度：行级锁以及表级锁。</p>
<p>应该尽量只锁定需要修改的那部分数据，而不是所有的资源。锁定的数据量越少，发生锁争用的可能就越小，系统的并发程度就越高。</p>
<p>但是加锁需要消耗资源，锁的各种操作（包括获取锁、释放锁、以及检查锁状态）都会增加系统开销。因此封锁粒度越小，系统开销就越大。</p>
<p>在选择封锁粒度时，需要在锁开销和并发程度之间做一个权衡。</p>
<p><img src="https://github.com/CyC2018/Interview-Notebook/raw/master/pics/1a851e90-0d5c-4d4f-ac54-34c20ecfb903.jpg" alt=""></p>
<h2 id="封锁类型"><a href="#封锁类型" class="headerlink" title="封锁类型"></a>封锁类型</h2><h3 id="1-读写锁"><a href="#1-读写锁" class="headerlink" title="1. 读写锁"></a>1. 读写锁</h3><ul>
<li>排它锁（Exclusive），简写为 X 锁，又称写锁。</li>
<li>共享锁（Shared），简写为 S 锁，又称读锁。</li>
</ul>
<p>有以下两个规定：</p>
<ul>
<li>一个事务对数据对象 A 加了 X 锁，就可以对 A 进行读取和更新。加锁期间其它事务不能对 A 加任何锁。</li>
<li>一个事务对数据对象 A 加了 S 锁，可以对 A 进行读取操作，但是不能进行更新操作。加锁期间其它事务能对 A 加 S 锁，但是不能加 X 锁。</li>
</ul>
<p>锁的兼容关系如下：</p>
<table>
<thead>
<tr>
<th style="text-align:center">-</th>
<th style="text-align:center">X</th>
<th style="text-align:center">S</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">X</td>
<td style="text-align:center">NO</td>
<td style="text-align:center">NO</td>
</tr>
<tr>
<td style="text-align:center">S</td>
<td style="text-align:center">NO</td>
<td style="text-align:center">YES</td>
</tr>
</tbody>
</table>
<h3 id="2-意向锁"><a href="#2-意向锁" class="headerlink" title="2. 意向锁"></a>2. 意向锁</h3><p>使用意向锁（Intention Locks）可以更容易地支持多粒度封锁。</p>
<p>在存在行级锁和表级锁的情况下，事务 T 想要对表 A 加 X 锁，就需要先检测是否有其它事务对表 A 或者表 A 中的任意一行加了锁，那么就需要对表 A 的每一行都检测一次，这是非常耗时的。</p>
<p>意向锁在原来的 X/S 锁之上引入了 IX/IS，IX/IS 都是表锁，用来表示一个事务想要在表中的某个数据行上加 X 锁或 S 锁。有以下两个规定：</p>
<ul>
<li>一个事务在获得某个数据行对象的 S 锁之前，必须先获得表的 IS 锁或者更强的锁；</li>
<li>一个事务在获得某个数据行对象的 X 锁之前，必须先获得表的 IX 锁。</li>
</ul>
<p>通过引入意向锁，事务 T 想要对表 A 加 X 锁，只需要先检测是否有其它事务对表 A 加了 X/IX/S/IS 锁，如果加了就表示有其它事务正在使用这个表或者表中某一行的锁，因此事务 T 加 X 锁失败。</p>
<p>各种锁的兼容关系如下：</p>
<table>
<thead>
<tr>
<th style="text-align:center">-</th>
<th style="text-align:center">X</th>
<th style="text-align:center">IX</th>
<th style="text-align:center">S</th>
<th style="text-align:center">IS</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">X</td>
<td style="text-align:center">NO</td>
<td style="text-align:center">NO</td>
<td style="text-align:center">NO</td>
<td style="text-align:center">NO</td>
</tr>
<tr>
<td style="text-align:center">IX</td>
<td style="text-align:center">NO</td>
<td style="text-align:center">YES</td>
<td style="text-align:center">NO</td>
<td style="text-align:center">YES</td>
</tr>
<tr>
<td style="text-align:center">S</td>
<td style="text-align:center">NO</td>
<td style="text-align:center">NO</td>
<td style="text-align:center">YES</td>
<td style="text-align:center">YES</td>
</tr>
<tr>
<td style="text-align:center">IS</td>
<td style="text-align:center">NO</td>
<td style="text-align:center">YES</td>
<td style="text-align:center">YES</td>
<td style="text-align:center">YES</td>
</tr>
</tbody>
</table>
<p>解释如下：</p>
<ul>
<li>任意 IS/IX 锁之间都是兼容的，因为它们只是表示想要对表加锁，而不是真正加锁；</li>
<li>S 锁只与 S 锁和 IS 锁兼容，也就是说事务 T 想要对数据行加 S 锁，其它事务可以已经获得对表或者表中的行的 S 锁。</li>
</ul>
<h2 id="封锁协议"><a href="#封锁协议" class="headerlink" title="封锁协议"></a>封锁协议</h2><h3 id="1-三级封锁协议"><a href="#1-三级封锁协议" class="headerlink" title="1. 三级封锁协议"></a>1. 三级封锁协议</h3><p><strong>一级封锁协议</strong></p>
<p>事务 T 要修改数据 A 时必须加 X 锁，直到 T 结束才释放锁。</p>
<p>可以解决丢失修改问题，因为不能同时有两个事务对同一个数据进行修改，那么事务的修改就不会被覆盖。</p>
<table>
<thead>
<tr>
<th style="text-align:center">T1</th>
<th style="text-align:center">T2</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">lock-x(A)</td>
<td style="text-align:center"></td>
</tr>
<tr>
<td style="text-align:center">read A=20</td>
<td style="text-align:center"></td>
</tr>
<tr>
<td style="text-align:center"></td>
<td style="text-align:center">lock-x(A)</td>
</tr>
<tr>
<td style="text-align:center"></td>
<td style="text-align:center">wait</td>
</tr>
<tr>
<td style="text-align:center">write A=19</td>
<td style="text-align:center">.</td>
</tr>
<tr>
<td style="text-align:center">commit</td>
<td style="text-align:center">.</td>
</tr>
<tr>
<td style="text-align:center">unlock-x(A)</td>
<td style="text-align:center">.</td>
</tr>
<tr>
<td style="text-align:center"></td>
<td style="text-align:center">obtain</td>
</tr>
<tr>
<td style="text-align:center"></td>
<td style="text-align:center">read A=19</td>
</tr>
<tr>
<td style="text-align:center"></td>
<td style="text-align:center">write A=21</td>
</tr>
<tr>
<td style="text-align:center"></td>
<td style="text-align:center">commit</td>
</tr>
<tr>
<td style="text-align:center"></td>
<td style="text-align:center">unlock-x(A)</td>
</tr>
</tbody>
</table>
<p><strong>二级封锁协议</strong></p>
<p>在一级的基础上，要求读取数据 A 时必须加 S 锁，读取完马上释放 S 锁。</p>
<p>可以解决读脏数据问题，因为如果一个事务在对数据 A 进行修改，根据 1 级封锁协议，会加 X 锁，那么就不能再加 S 锁了，也就是不会读入数据。</p>
<table>
<thead>
<tr>
<th style="text-align:center">T1</th>
<th style="text-align:center">T2</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">lock-x(A)</td>
<td style="text-align:center"></td>
</tr>
<tr>
<td style="text-align:center">read A=20</td>
<td style="text-align:center"></td>
</tr>
<tr>
<td style="text-align:center">write A=19</td>
<td style="text-align:center"></td>
</tr>
<tr>
<td style="text-align:center"></td>
<td style="text-align:center">lock-s(A)</td>
</tr>
<tr>
<td style="text-align:center"></td>
<td style="text-align:center">wait</td>
</tr>
<tr>
<td style="text-align:center">rollback</td>
<td style="text-align:center">.</td>
</tr>
<tr>
<td style="text-align:center">A=20</td>
<td style="text-align:center">.</td>
</tr>
<tr>
<td style="text-align:center">unlock-x(A)</td>
<td style="text-align:center">.</td>
</tr>
<tr>
<td style="text-align:center"></td>
<td style="text-align:center">obtain</td>
</tr>
<tr>
<td style="text-align:center"></td>
<td style="text-align:center">read A=20</td>
</tr>
<tr>
<td style="text-align:center"></td>
<td style="text-align:center">commit</td>
</tr>
<tr>
<td style="text-align:center"></td>
<td style="text-align:center">unlock-s(A)</td>
</tr>
</tbody>
</table>
<p><strong>三级封锁协议</strong></p>
<p>在二级的基础上，要求读取数据 A 时必须加 S 锁，直到事务结束了才能释放 S 锁。</p>
<p>可以解决不可重复读的问题，因为读 A 时，其它事务不能对 A 加 X 锁，从而避免了在读的期间数据发生改变。</p>
<table>
<thead>
<tr>
<th style="text-align:center">T1</th>
<th style="text-align:center">T2</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">lock-s(A)</td>
<td style="text-align:center"></td>
</tr>
<tr>
<td style="text-align:center">read A=20</td>
<td style="text-align:center"></td>
</tr>
<tr>
<td style="text-align:center"></td>
<td style="text-align:center">lock-x(A)</td>
</tr>
<tr>
<td style="text-align:center"></td>
<td style="text-align:center">wait</td>
</tr>
<tr>
<td style="text-align:center">read A=20</td>
<td style="text-align:center">.</td>
</tr>
<tr>
<td style="text-align:center">commit</td>
<td style="text-align:center">.</td>
</tr>
<tr>
<td style="text-align:center">unlock-s(A)</td>
<td style="text-align:center">.</td>
</tr>
<tr>
<td style="text-align:center"></td>
<td style="text-align:center">obtain</td>
</tr>
<tr>
<td style="text-align:center"></td>
<td style="text-align:center">read A=20</td>
</tr>
<tr>
<td style="text-align:center"></td>
<td style="text-align:center">write A=19</td>
</tr>
<tr>
<td style="text-align:center"></td>
<td style="text-align:center">commit</td>
</tr>
<tr>
<td style="text-align:center"></td>
<td style="text-align:center">unlock-X(A)</td>
</tr>
</tbody>
</table>
<h3 id="2-两段锁协议"><a href="#2-两段锁协议" class="headerlink" title="2. 两段锁协议"></a>2. 两段锁协议</h3><p>加锁和解锁分为两个阶段进行。</p>
<p>可串行化调度是指，通过并发控制，使得并发执行的事务结果与某个串行执行的事务结果相同。</p>
<p>事务遵循两段锁协议是保证可串行化调度的充分条件。例如以下操作满足两段锁协议，它是可串行化调度。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">lock-x(A)...lock-s(B)...lock-s(C)...unlock(A)...unlock(C)...unlock(B)</span><br></pre></td></tr></table></figure>
<p>但不是必要条件，例如以下操作不满足两段锁协议，但是它还是可串行化调度。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">lock-x(A)...unlock(A)...lock-s(B)...unlock(B)...lock-s(C)...unlock(C)</span><br></pre></td></tr></table></figure>
<h2 id="MySQL-隐式与显示锁定"><a href="#MySQL-隐式与显示锁定" class="headerlink" title="MySQL 隐式与显示锁定"></a>MySQL 隐式与显示锁定</h2><p>MySQL 的 InnoDB 存储引擎采用两段锁协议，会根据隔离级别在需要的时候自动加锁，并且所有的锁都是在同一时刻被释放，这被称为隐式锁定。</p>
<p>InnoDB 也可以使用特定的语句进行显示锁定：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">SELECT ... LOCK In SHARE MODE;</span><br><span class="line">SELECT ... FOR UPDATE;</span><br></pre></td></tr></table></figure>
<h1 id="四、隔离级别"><a href="#四、隔离级别" class="headerlink" title="四、隔离级别"></a>四、隔离级别</h1><h2 id="未提交读（READ-UNCOMMITTED）"><a href="#未提交读（READ-UNCOMMITTED）" class="headerlink" title="未提交读（READ UNCOMMITTED）"></a>未提交读（READ UNCOMMITTED）</h2><p>事务中的修改，即使没有提交，对其它事务也是可见的。</p>
<h2 id="提交读（READ-COMMITTED）"><a href="#提交读（READ-COMMITTED）" class="headerlink" title="提交读（READ COMMITTED）"></a>提交读（READ COMMITTED）</h2><p>一个事务只能读取已经提交的事务所做的修改。换句话说，一个事务所做的修改在提交之前对其它事务是不可见的。</p>
<h2 id="可重复读（REPEATABLE-READ）"><a href="#可重复读（REPEATABLE-READ）" class="headerlink" title="可重复读（REPEATABLE READ）"></a>可重复读（REPEATABLE READ）</h2><p>保证在同一个事务中多次读取同样数据的结果是一样的。</p>
<h2 id="可串行化（SERIALIZABLE）"><a href="#可串行化（SERIALIZABLE）" class="headerlink" title="可串行化（SERIALIZABLE）"></a>可串行化（SERIALIZABLE）</h2><p>强制事务串行执行。</p>
<hr>
<p>（注：YES：导致；NO：避免）<br>| 隔离级别 | 脏读 | 不可重复读 | 幻影读 |<br>| :-: | :-: | :-: | :-: |<br>| 未提交读 | YES | YES | YES |<br>| 提交读 | NO | YES | YES |<br>| 可重复读 | NO | NO | YES |<br>| 可串行化 | NO | NO | NO |</p>
<h1 id="五、多版本并发控制"><a href="#五、多版本并发控制" class="headerlink" title="五、多版本并发控制"></a>五、多版本并发控制</h1><p>多版本并发控制（Multi-Version Concurrency Control, MVCC）是 MySQL 的 InnoDB 存储引擎实现隔离级别的一种具体方式，用于实现提交读和可重复读这两种隔离级别。</p>
<p>而未提交读隔离级别总是读取最新的数据行，无需使用 MVCC。</p>
<p>可串行化隔离级别需要对所有读取的行都加锁，单纯使用 MVCC 无法实现。</p>
<h2 id="版本号"><a href="#版本号" class="headerlink" title="版本号"></a>版本号</h2><ul>
<li>系统版本号：是一个递增的数字，每开始一个新的事务，系统版本号就会自动递增。</li>
<li>事务版本号：事务开始时的系统版本号。</li>
</ul>
<p>InooDB 的 MVCC 在每行记录后面都保存着两个隐藏的列，用来存储两个版本号：</p>
<ul>
<li>创建版本号：指示创建一个数据行的快照时的系统版本号；</li>
<li>删除版本号：如果该快照的删除版本号大于当前事务版本号表示该快照有效，否则表示该快照已经被删除了。</li>
</ul>
<h2 id="Undo-日志"><a href="#Undo-日志" class="headerlink" title="Undo 日志"></a>Undo 日志</h2><p>InnoDB 的 MVCC 使用到的快照存储在 Undo 日志中，该日志通过回滚指针把一个数据行（Record）的所有快照连接起来。</p>
<p><img src="https://github.com/CyC2018/Interview-Notebook/raw/master/pics/e41405a8-7c05-4f70-8092-e961e28d3112.jpg" alt=""></p>
<h2 id="实现过程"><a href="#实现过程" class="headerlink" title="实现过程"></a>实现过程</h2><p>以下实现过程针对可重复读隔离级别。</p>
<h3 id="1-SELECT"><a href="#1-SELECT" class="headerlink" title="1. SELECT"></a>1. SELECT</h3><p>当开始新的一个事务时，该事务的版本号肯定会大于当前所有数据行快照的创建版本号，理解这一点很关键。</p>
<p>多个事务必须读取到同一个数据行的快照，并且这个快照是距离现在最近的一个有效快照。但是也有例外，如果有一个事务正在修改该数据行，那么它可以读取事务本身所做的修改，而不用和其它事务的读取结果一致。</p>
<p>把没有对一个数据行做修改的事务称为 T，T 所要读取的数据行快照的创建版本号必须小于 T 的版本号，因为如果大于或者等于 T 的版本号，那么表示该数据行快照是其它事务的最新修改，因此不能去读取它。</p>
<p>除了上面的要求，T 所要读取的数据行快照的删除版本号必须大于 T 的版本号，因为如果小于等于 T 的版本号，那么表示该数据行快照是已经被删除的，不应该去读取它。</p>
<h3 id="2-INSERT"><a href="#2-INSERT" class="headerlink" title="2. INSERT"></a>2. INSERT</h3><p>将当前系统版本号作为数据行快照的创建版本号。</p>
<h3 id="3-DELETE"><a href="#3-DELETE" class="headerlink" title="3. DELETE"></a>3. DELETE</h3><p>将当前系统版本号作为数据行快照的删除版本号。</p>
<h3 id="4-UPDATE"><a href="#4-UPDATE" class="headerlink" title="4. UPDATE"></a>4. UPDATE</h3><p>将当前系统版本号作为更新前的数据行快照的删除版本号，并将当前系统版本号作为更新后的数据行快照的创建版本号。可以理解为先执行 DELETE 后执行 INSERT。</p>
<h2 id="快照读与当前读"><a href="#快照读与当前读" class="headerlink" title="快照读与当前读"></a>快照读与当前读</h2><h3 id="1-快照读"><a href="#1-快照读" class="headerlink" title="1. 快照读"></a>1. 快照读</h3><p>使用 MVCC 读取的是快照中的数据，这样可以减少加锁所带来的开销。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select * from table ...;</span><br></pre></td></tr></table></figure>
<h3 id="2-当前读"><a href="#2-当前读" class="headerlink" title="2. 当前读"></a>2. 当前读</h3><p>读取的是最新的数据，需要加锁。以下第一个语句需要加 S 锁，其它都需要加 X 锁。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">select * from table where ? lock in share mode;</span><br><span class="line">select * from table where ? for update;</span><br><span class="line">insert;</span><br><span class="line">update;</span><br><span class="line">delete;</span><br></pre></td></tr></table></figure>
<h1 id="六、Next-Key-Locks"><a href="#六、Next-Key-Locks" class="headerlink" title="六、Next-Key Locks"></a>六、Next-Key Locks</h1><p>Next-Key Locks 是 MySQL 的 InnoDB 存储引擎的一种锁实现。</p>
<p>MVCC 不能解决幻读的问题，Next-Key Locks 就是为了解决这个问题而存在的。在可重复读（REPEATABLE READ）隔离级别下，使用 MVCC + Next-Key Locks 可以解决幻读问题。</p>
<h2 id="Record-Locks"><a href="#Record-Locks" class="headerlink" title="Record Locks"></a>Record Locks</h2><p>锁定一个记录上的索引，而不是记录本身。</p>
<p>如果表没有设置索引，InnoDB 会自动在主键上创建隐藏的聚集索引，因此 Record Locks 依然可以使用。</p>
<h2 id="Gap-Locks"><a href="#Gap-Locks" class="headerlink" title="Gap Locks"></a>Gap Locks</h2><p>锁定索引之间的间隙，但是不包含索引本身。例如当一个事务执行以下语句，其它事务就不能在 t.c 中插入 15。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SELECT c FROM t WHERE c BETWEEN 10 and 20 FOR UPDATE;</span><br></pre></td></tr></table></figure>
<h2 id="Next-Key-Locks"><a href="#Next-Key-Locks" class="headerlink" title="Next-Key Locks"></a>Next-Key Locks</h2><p>它是 Record Locks 和 Gap Locks 的结合，不仅锁定一个记录上的索引，也锁定范围内的索引。例如一个索引包含以下值：10, 11, 13, and 20，那么就需要锁定以下区间：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">(negative infinity, 10]</span><br><span class="line">(10, 11]</span><br><span class="line">(11, 13]</span><br><span class="line">(13, 20]</span><br><span class="line">(20, positive infinity)</span><br></pre></td></tr></table></figure>
<h1 id="七、关系数据库设计理论"><a href="#七、关系数据库设计理论" class="headerlink" title="七、关系数据库设计理论"></a>七、关系数据库设计理论</h1><h2 id="函数依赖"><a href="#函数依赖" class="headerlink" title="函数依赖"></a>函数依赖</h2><p>记 A-&gt;B 表示 A 函数决定 B，也可以说 B 函数依赖于 A。</p>
<p>如果 {A1，A2，… ，An} 是关系的一个或多个属性的集合，该集合函数决定了关系的其它所有属性并且是最小的，那么该集合就称为键码。</p>
<p>对于 A-&gt;B，如果能找到 A 的真子集 A’，使得 A’-&gt; B，那么 A-&gt;B 就是部分函数依赖，否则就是完全函数依赖。</p>
<p>对于 A-&gt;B，B-&gt;C，则 A-&gt;C 是一个传递函数依赖。</p>
<h2 id="异常"><a href="#异常" class="headerlink" title="异常"></a>异常</h2><p>以下的学生课程关系的函数依赖为 Sno, Cname -&gt; Sname, Sdept, Mname, Grade，键码为 {Sno, Cname}。也就是说，确定学生和课程之后，就能确定其它信息。</p>
<table>
<thead>
<tr>
<th style="text-align:center">Sno</th>
<th style="text-align:center">Sname</th>
<th style="text-align:center">Sdept</th>
<th style="text-align:center">Mname</th>
<th style="text-align:center">Cname</th>
<th style="text-align:center">Grade</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">1</td>
<td style="text-align:center">学生-1</td>
<td style="text-align:center">学院-1</td>
<td style="text-align:center">院长-1</td>
<td style="text-align:center">课程-1</td>
<td style="text-align:center">90</td>
</tr>
<tr>
<td style="text-align:center">2</td>
<td style="text-align:center">学生-2</td>
<td style="text-align:center">学院-2</td>
<td style="text-align:center">院长-2</td>
<td style="text-align:center">课程-2</td>
<td style="text-align:center">80</td>
</tr>
<tr>
<td style="text-align:center">2</td>
<td style="text-align:center">学生-2</td>
<td style="text-align:center">学院-2</td>
<td style="text-align:center">院长-2</td>
<td style="text-align:center">课程-1</td>
<td style="text-align:center">100</td>
</tr>
<tr>
<td style="text-align:center">3</td>
<td style="text-align:center">学生-3</td>
<td style="text-align:center">学院-2</td>
<td style="text-align:center">院长-2</td>
<td style="text-align:center">课程-2</td>
<td style="text-align:center">95</td>
</tr>
</tbody>
</table>
<p>不符合范式的关系，会产生很多异常，主要有以下四种异常：</p>
<ul>
<li>冗余数据：例如 学生-2 出现了两次。</li>
<li>修改异常：修改了一个记录中的信息，但是另一个记录中相同的信息却没有被修改。</li>
<li>删除异常：删除一个信息，那么也会丢失其它信息。例如如果删除了 课程-1，需要删除第一行和第三行，那么 学生-1 的信息就会丢失。</li>
<li>插入异常，例如想要插入一个学生的信息，如果这个学生还没选课，那么就无法插入。</li>
</ul>
<h2 id="范式"><a href="#范式" class="headerlink" title="范式"></a>范式</h2><p>范式理论是为了解决以上提到四种异常。</p>
<p>高级别范式的依赖于低级别的范式，1NF 是最低级别的范式。</p>
<p><img src="https://github.com/CyC2018/Interview-Notebook/raw/master/pics/c2d343f7-604c-4856-9a3c-c71d6f67fecc.png" alt=""></p>
<h3 id="1-第一范式-1NF"><a href="#1-第一范式-1NF" class="headerlink" title="1. 第一范式 (1NF)"></a>1. 第一范式 (1NF)</h3><p>属性不可分。</p>
<h3 id="2-第二范式-2NF"><a href="#2-第二范式-2NF" class="headerlink" title="2. 第二范式 (2NF)"></a>2. 第二范式 (2NF)</h3><p>每个非主属性完全函数依赖于键码。</p>
<p>可以通过分解来满足。</p>
<p><strong>分解前</strong> </p>
<table>
<thead>
<tr>
<th style="text-align:center">Sno</th>
<th style="text-align:center">Sname</th>
<th style="text-align:center">Sdept</th>
<th style="text-align:center">Mname</th>
<th style="text-align:center">Cname</th>
<th style="text-align:center">Grade</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">1</td>
<td style="text-align:center">学生-1</td>
<td style="text-align:center">学院-1</td>
<td style="text-align:center">院长-1</td>
<td style="text-align:center">课程-1</td>
<td style="text-align:center">90</td>
</tr>
<tr>
<td style="text-align:center">2</td>
<td style="text-align:center">学生-2</td>
<td style="text-align:center">学院-2</td>
<td style="text-align:center">院长-2</td>
<td style="text-align:center">课程-2</td>
<td style="text-align:center">80</td>
</tr>
<tr>
<td style="text-align:center">2</td>
<td style="text-align:center">学生-2</td>
<td style="text-align:center">学院-2</td>
<td style="text-align:center">院长-2</td>
<td style="text-align:center">课程-1</td>
<td style="text-align:center">100</td>
</tr>
<tr>
<td style="text-align:center">3</td>
<td style="text-align:center">学生-3</td>
<td style="text-align:center">学院-2</td>
<td style="text-align:center">院长-2</td>
<td style="text-align:center">课程-2</td>
<td style="text-align:center">95</td>
</tr>
</tbody>
</table>
<p>以上学生课程关系中，{Sno, Cname} 为键码，有如下函数依赖：</p>
<ul>
<li>Sno -&gt; Sname, Sdept</li>
<li>Sdept -&gt; Mname</li>
<li>Sno, Cname-&gt; Grade</li>
</ul>
<p>Grade 完全函数依赖于键码，它没有任何冗余数据，每个学生的每门课都有特定的成绩。</p>
<p>Sname, Sdept 和 Mname 都部分依赖于键码，当一个学生选修了多门课时，这些数据就会出现多次，造成大量冗余数据。</p>
<p><strong>分解后</strong> </p>
<p>关系-1</p>
<table>
<thead>
<tr>
<th style="text-align:center">Sno</th>
<th style="text-align:center">Sname</th>
<th style="text-align:center">Sdept</th>
<th style="text-align:center">Mname</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">1</td>
<td style="text-align:center">学生-1</td>
<td style="text-align:center">学院-1</td>
<td style="text-align:center">院长-1</td>
</tr>
<tr>
<td style="text-align:center">2</td>
<td style="text-align:center">学生-2</td>
<td style="text-align:center">学院-2</td>
<td style="text-align:center">院长-2</td>
</tr>
<tr>
<td style="text-align:center">3</td>
<td style="text-align:center">学生-3</td>
<td style="text-align:center">学院-2</td>
<td style="text-align:center">院长-2</td>
</tr>
</tbody>
</table>
<p>有以下函数依赖：</p>
<ul>
<li>Sno -&gt; Sname, Sdept</li>
<li>Sdept -&gt; Mname</li>
</ul>
<p>关系-2</p>
<table>
<thead>
<tr>
<th style="text-align:center">Sno</th>
<th style="text-align:center">Cname</th>
<th style="text-align:center">Grade</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">1</td>
<td style="text-align:center">课程-1</td>
<td style="text-align:center">90</td>
</tr>
<tr>
<td style="text-align:center">2</td>
<td style="text-align:center">课程-2</td>
<td style="text-align:center">80</td>
</tr>
<tr>
<td style="text-align:center">2</td>
<td style="text-align:center">课程-1</td>
<td style="text-align:center">100</td>
</tr>
<tr>
<td style="text-align:center">3</td>
<td style="text-align:center">课程-2</td>
<td style="text-align:center">95</td>
</tr>
</tbody>
</table>
<p>有以下函数依赖：</p>
<ul>
<li>Sno, Cname -&gt; Grade</li>
</ul>
<h3 id="3-第三范式-3NF"><a href="#3-第三范式-3NF" class="headerlink" title="3. 第三范式 (3NF)"></a>3. 第三范式 (3NF)</h3><p>非主属性不传递函数依赖于键码。</p>
<p>上面的 关系-1 中存在以下传递函数依赖：Sno -&gt; Sdept -&gt; Mname，可以进行以下分解：</p>
<p>关系-11</p>
<table>
<thead>
<tr>
<th style="text-align:center">Sno</th>
<th style="text-align:center">Sname</th>
<th style="text-align:center">Sdept</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">1</td>
<td style="text-align:center">学生-1</td>
<td style="text-align:center">学院-1</td>
</tr>
<tr>
<td style="text-align:center">2</td>
<td style="text-align:center">学生-2</td>
<td style="text-align:center">学院-2</td>
</tr>
<tr>
<td style="text-align:center">3</td>
<td style="text-align:center">学生-3</td>
<td style="text-align:center">学院-2</td>
</tr>
</tbody>
</table>
<p>关系-12</p>
<table>
<thead>
<tr>
<th style="text-align:center">Sdept</th>
<th style="text-align:center">Mname</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">学院-1</td>
<td style="text-align:center">院长-1</td>
</tr>
<tr>
<td style="text-align:center">学院-2</td>
<td style="text-align:center">院长-2</td>
</tr>
</tbody>
</table>
<h1 id="八、ER-图"><a href="#八、ER-图" class="headerlink" title="八、ER 图"></a>八、ER 图</h1><p>Entity-Relationship，有三个组成部分：实体、属性、联系。</p>
<p>用来进行关系型数据库系统的概念设计。</p>
<h2 id="实体的三种联系"><a href="#实体的三种联系" class="headerlink" title="实体的三种联系"></a>实体的三种联系</h2><p>包含一对一，一对多，多对多三种。</p>
<p>如果 A 到 B 是一对多关系，那么画个带箭头的线段指向 B；如果是一对一，画两个带箭头的线段；如果是多对多，画两个不带箭头的线段。下图的 Course 和 Student 是一对多的关系。</p>
<p><img src="https://github.com/CyC2018/Interview-Notebook/raw/master/pics/292b4a35-4507-4256-84ff-c218f108ee31.jpg" alt=""></p>
<h2 id="表示出现多次的关系"><a href="#表示出现多次的关系" class="headerlink" title="表示出现多次的关系"></a>表示出现多次的关系</h2><p>一个实体在联系出现几次，就要用几条线连接。下图表示一个课程的先修关系，先修关系出现两个 Course 实体，第一个是先修课程，后一个是后修课程，因此需要用两条线来表示这种关系。</p>
<p><img src="https://github.com/CyC2018/Interview-Notebook/raw/master/pics/8b798007-e0fb-420c-b981-ead215692417.jpg" alt=""></p>
<h2 id="联系的多向性"><a href="#联系的多向性" class="headerlink" title="联系的多向性"></a>联系的多向性</h2><p>虽然老师可以开设多门课，并且可以教授多名学生，但是对于特定的学生和课程，只有一个老师教授，这就构成了一个三元联系。</p>
<p><img src="https://github.com/CyC2018/Interview-Notebook/raw/master/pics/423f2a40-bee1-488e-b460-8e76c48ee560.png" alt=""></p>
<p>一般只使用二元联系，可以把多元关系转换为二元关系。</p>
<p><img src="https://github.com/CyC2018/Interview-Notebook/raw/master/pics/de9b9ea0-1327-4865-93e5-6f805c48bc9e.png" alt=""></p>
<h2 id="表示子类"><a href="#表示子类" class="headerlink" title="表示子类"></a>表示子类</h2><p>用一个三角形和两条线来连接类和子类，与子类有关的属性和联系都连到子类上，而与父类和子类都有关的连到父类上。</p>
<p><img src="https://github.com/CyC2018/Interview-Notebook/raw/master/pics/7ec9d619-fa60-4a2b-95aa-bf1a62aad408.jpg" alt=""></p>
<h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><ul>
<li>AbrahamSilberschatz, HenryF.Korth, S.Sudarshan, 等. 数据库系统概念 [M]. 机械工业出版社, 2006.</li>
<li>施瓦茨. 高性能 MYSQL(第3版)[M]. 电子工业出版社, 2013.</li>
<li>史嘉权. 数据库系统概论[M]. 清华大学出版社有限公司, 2006.</li>
<li><a href="https://dev.mysql.com/doc/refman/5.7/en/innodb-storage-engine.html" target="_blank" rel="noopener">The InnoDB Storage Engine</a></li>
<li><a href="https://www.slideshare.net/ErnestoHernandezRodriguez/transaction-isolation-levels" target="_blank" rel="noopener">Transaction isolation levels</a></li>
<li><a href="http://scanftree.com/dbms/2-phase-locking-protocol" target="_blank" rel="noopener">Concurrency Control</a></li>
<li><a href="https://www.slideshare.net/brshristov/the-nightmare-of-locking-blocking-and-isolation-levels-46391666" target="_blank" rel="noopener">The Nightmare of Locking, Blocking and Isolation Levels!</a></li>
<li><a href="https://aksakalli.github.io/2012/03/12/database-normalization-and-normal-forms-with-an-example.html" target="_blank" rel="noopener">Database Normalization and Normal Forms with an Example</a></li>
<li><a href="https://blog.jcole.us/2014/04/16/the-basics-of-the-innodb-undo-logging-and-history-system/" target="_blank" rel="noopener">The basics of the InnoDB undo logging and history system</a></li>
<li><a href="https://www.brightbox.com/blog/2013/10/31/on-mysql-locks/" target="_blank" rel="noopener">MySQL locking for the busy web developer</a></li>
<li><a href="https://draveness.me/mysql-innodb" target="_blank" rel="noopener">浅入浅出 MySQL 和 InnoDB</a></li>
<li><a href="https://tech.meituan.com/innodb-lock.html" target="_blank" rel="noopener">Innodb 中的事务隔离级别和锁的关系</a></li>
</ul>

        </div>
    

</div>
            
                
<div class="post">

    <div class="post-header index">
        <h1 class="title">
            <a href="/2018/08/16/反射工具类/">
                反射工具类
            </a>
        </h1>
        <div class="post-info">
            
                <span class="date">2018-08-16</span>
            
            
            
        </div>
    </div>

    
        <div class="content">
            <p>先封装一个反射的工具类，代码如下所示。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.lovo.util;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">TypeConverter</span> </span>&#123;</span><br><span class="line"> </span><br><span class="line">	<span class="function"><span class="keyword">public</span> Object <span class="title">convert</span><span class="params">(Class&lt;?&gt; elemType, String value)</span> <span class="keyword">throws</span> Exception</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.lovo.util;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Constructor;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Field;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Modifier;</span><br><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"> </span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 反射工具类</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> 骆昊</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ReflectionUtil</span> </span>&#123;</span><br><span class="line"> </span><br><span class="line">	<span class="function"><span class="keyword">private</span> <span class="title">ReflectionUtil</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">throw</span> <span class="keyword">new</span> AssertionError();</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * 根据字段名查找字段的类型</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@param</span> target 目标对象</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@param</span> fieldName 字段名</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@return</span> 字段的类型</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> Class&lt;?&gt; getFieldType(Object target, String fieldName) &#123;</span><br><span class="line">		Class&lt;?&gt; clazz = target.getClass();</span><br><span class="line">		String[] fs = fieldName.split(<span class="string">"\\."</span>);</span><br><span class="line">		</span><br><span class="line">		<span class="keyword">try</span> &#123;</span><br><span class="line">			<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; fs.length - <span class="number">1</span>; i++) &#123;</span><br><span class="line">				Field f = clazz.getDeclaredField(fs[i]);</span><br><span class="line">				target = f.getType().newInstance();</span><br><span class="line">				clazz = target.getClass();</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">return</span> clazz.getDeclaredField(fs[fs.length - <span class="number">1</span>]).getType();</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">catch</span>(Exception e) &#123;</span><br><span class="line">		        <span class="comment">// throw new RuntimeException(e);</span></span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * 获取对象所有字段的名字</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@param</span> obj 目标对象</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@return</span> 字段名字的数组</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> String[] getFieldNames(Object obj) &#123;</span><br><span class="line">		Class&lt;?&gt; clazz = obj.getClass();</span><br><span class="line">		Field[] fields = clazz.getDeclaredFields();</span><br><span class="line">		List&lt;String&gt; fieldNames = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; fields.length; i++) &#123;</span><br><span class="line">			<span class="keyword">if</span>((fields[i].getModifiers() &amp; Modifier.STATIC) == <span class="number">0</span>) &#123;</span><br><span class="line">				fieldNames.add(fields[i].getName());</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> fieldNames.toArray(<span class="keyword">new</span> String[fieldNames.size()]);</span><br><span class="line">	&#125;</span><br><span class="line"> </span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * 通过反射取对象指定字段(属性)的值</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@param</span> target 目标对象</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@param</span> fieldName 字段的名字</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@throws</span> 如果取不到对象指定字段的值则抛出异常</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@return</span> 字段的值</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Object <span class="title">getValue</span><span class="params">(Object target, String fieldName)</span> </span>&#123;</span><br><span class="line">		Class&lt;?&gt; clazz = target.getClass();</span><br><span class="line">		String[] fs = fieldName.split(<span class="string">"\\."</span>);</span><br><span class="line">		</span><br><span class="line">		<span class="keyword">try</span> &#123;</span><br><span class="line">			<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; fs.length - <span class="number">1</span>; i++) &#123;</span><br><span class="line">				Field f = clazz.getDeclaredField(fs[i]);</span><br><span class="line">				f.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">				target = f.get(target);</span><br><span class="line">				clazz = target.getClass();</span><br><span class="line">			&#125;</span><br><span class="line">		</span><br><span class="line">			Field f = clazz.getDeclaredField(fs[fs.length - <span class="number">1</span>]);</span><br><span class="line">			f.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">			<span class="keyword">return</span> f.get(target);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">			<span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(e);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * 通过反射给对象的指定字段赋值</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@param</span> target 目标对象</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@param</span> fieldName 字段的名称</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@param</span> value 值</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">setValue</span><span class="params">(Object target, String fieldName, Object value)</span> </span>&#123;</span><br><span class="line">		Class&lt;?&gt; clazz = target.getClass();</span><br><span class="line">		String[] fs = fieldName.split(<span class="string">"\\."</span>);</span><br><span class="line">		<span class="keyword">try</span> &#123;</span><br><span class="line">			<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; fs.length - <span class="number">1</span>; i++) &#123;</span><br><span class="line">				Field f = clazz.getDeclaredField(fs[i]);</span><br><span class="line">				f.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">				Object val = f.get(target);</span><br><span class="line">				<span class="keyword">if</span>(val == <span class="keyword">null</span>) &#123;</span><br><span class="line">					Constructor&lt;?&gt; c = f.getType().getDeclaredConstructor();</span><br><span class="line">					c.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">					val = c.newInstance();</span><br><span class="line">					f.set(target, val);</span><br><span class="line">				&#125;</span><br><span class="line">				target = val;</span><br><span class="line">				clazz = target.getClass();</span><br><span class="line">			&#125;</span><br><span class="line">		</span><br><span class="line">			Field f = clazz.getDeclaredField(fs[fs.length - <span class="number">1</span>]);</span><br><span class="line">			f.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">			f.set(target, value);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">			<span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(e);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这个工具类中封装了四个方法，通过这个工具类可以给对象的指定字段赋值，也可以获取对象指定字段的值和类型，对于对象的某个字段又是一个对象的情况，上面的工具类也能够提供很好的处理，例如 person 对象关联了 car 对象，car 对象关联了 producer 对象，producer 对象有 name 属性，可以用 ReflectionUtil.get(person, “car.producer.name”) 来获取 name 属性的值。</p>

        </div>
    

</div>
            
                
<div class="post">

    <div class="post-header index">
        <h1 class="title">
            <a href="/2018/08/13/TCP与UDP/">
                TCP与UDP
            </a>
        </h1>
        <div class="post-info">
            
                <span class="date">2018-08-13</span>
            
            
            
        </div>
    </div>

    
        <div class="content">
            <h1 id="UDP协议"><a href="#UDP协议" class="headerlink" title="UDP协议"></a>UDP协议</h1><h5 id="UDP-User-Datagram-Protocol-用户数据报协议"><a href="#UDP-User-Datagram-Protocol-用户数据报协议" class="headerlink" title="UDP:User Datagram Protocol,用户数据报协议."></a><strong>UDP</strong>:User Datagram Protocol,用户数据报协议.</h5><h5 id="主要作用：将网络数据压缩成数据包的形式。"><a href="#主要作用：将网络数据压缩成数据包的形式。" class="headerlink" title="主要作用：将网络数据压缩成数据包的形式。"></a><strong>主要作用</strong>：将网络数据压缩成数据包的形式。</h5><h6 id="数据包：一个二进制数据的传输单位"><a href="#数据包：一个二进制数据的传输单位" class="headerlink" title="数据包：一个二进制数据的传输单位"></a><em>数据包：一个二进制数据的传输单位</em></h6><h5 id="工作机制：蛮干型。它想传送时就简单地去抓取来自应用程序的数据，并尽可能快地把它扔到网络上。因此，在发送端，UDP传送数据的速度仅仅是受应用程序生成数据的速度、计算机的能力和传输带宽的限制；在接收端，UDP把每个消息段放在队列中，应用程序每次从队列中读一个消息段。"><a href="#工作机制：蛮干型。它想传送时就简单地去抓取来自应用程序的数据，并尽可能快地把它扔到网络上。因此，在发送端，UDP传送数据的速度仅仅是受应用程序生成数据的速度、计算机的能力和传输带宽的限制；在接收端，UDP把每个消息段放在队列中，应用程序每次从队列中读一个消息段。" class="headerlink" title="工作机制：蛮干型。它想传送时就简单地去抓取来自应用程序的数据，并尽可能快地把它扔到网络上。因此，在发送端，UDP传送数据的速度仅仅是受应用程序生成数据的速度、计算机的能力和传输带宽的限制；在接收端，UDP把每个消息段放在队列中，应用程序每次从队列中读一个消息段。"></a><strong>工作机制</strong>：蛮干型。它想传送时就简单地去抓取来自应用程序的数据，并尽可能快地把它扔到网络上。因此，在发送端，UDP传送数据的速度仅仅是受应用程序生成数据的速度、计算机的能力和传输带宽的限制；在接收端，UDP把每个消息段放在队列中，应用程序每次从队列中读一个消息段。</h5><h5 id="优势：速度快，较安全。"><a href="#优势：速度快，较安全。" class="headerlink" title="优势：速度快，较安全。"></a><strong>优势</strong>：速度快，较安全。</h5><p>与TCP协议相比，UDP协议排除了信息可靠传递机制，也就是减少了TCP协议中提供数据包分组、组装和排序的过程需要的时间消耗。其次，UDP是一个无状态的传输协议，所以它在传递数据时非常快。没有TCP的这些机制，UDP较TCP被攻击者利用的漏洞就要少一些。</p>
<h5 id="劣势：可靠性差。"><a href="#劣势：可靠性差。" class="headerlink" title="劣势：可靠性差。"></a><strong>劣势</strong>：可靠性差。</h5><p>UDP协议是一种无连接的传输协议，排除信息可靠传递机制带来速度优势的同时，显然降低了可靠性的需求，也就是UDP协议无法得知其是否<strong>安全</strong>，<strong>完整</strong>到达的。</p>
<h5 id="应用"><a href="#应用" class="headerlink" title="应用"></a><strong>应用</strong></h5><p>因为UDP协议的控制选项较少，在数据传输过程中<strong>延迟小、数据传输效率高</strong>，适合对可靠性要求不高的应用程序，或者可以保障可靠性的应用程序，如DNS、TFTP、SNMP等。<br>在生活中音频、视频和普通数据都可以采用UDP协议来进行数据传输，比如腾讯QQ这些社交软件也多采用UDP。</p>
<h1 id="TCP协议"><a href="#TCP协议" class="headerlink" title="TCP协议"></a>TCP协议</h1><h5 id="TCP-Transmission-Control-Protocol-传输控制协议"><a href="#TCP-Transmission-Control-Protocol-传输控制协议" class="headerlink" title="TCP:Transmission Control Protocol 传输控制协议"></a><strong>TCP</strong>:Transmission Control Protocol 传输控制协议</h5><h5 id="主要作用：把数据流分割成适当长度的报文段之后"><a href="#主要作用：把数据流分割成适当长度的报文段之后" class="headerlink" title="主要作用：把数据流分割成适当长度的报文段之后"></a><strong>主要作用</strong>：把数据流分割成适当长度的报文段之后</h5><h5 id="工作机制：紧小细微型。面向连接意味着两个使用TCP的应用（通常是一个客户和一个服务器）在彼此交换数据包之前必须先建立一个TCP连接。这一过程与打电话很相似，先拨号振铃，等待对方摘机说“喂”，然后才说明是谁。在一个TCP连接中，仅有两方进行彼此通信。而UDP更像是发短信，将发送方所有的信息，将所有信息一股脑儿全扔到网络中。"><a href="#工作机制：紧小细微型。面向连接意味着两个使用TCP的应用（通常是一个客户和一个服务器）在彼此交换数据包之前必须先建立一个TCP连接。这一过程与打电话很相似，先拨号振铃，等待对方摘机说“喂”，然后才说明是谁。在一个TCP连接中，仅有两方进行彼此通信。而UDP更像是发短信，将发送方所有的信息，将所有信息一股脑儿全扔到网络中。" class="headerlink" title="工作机制：紧小细微型。面向连接意味着两个使用TCP的应用（通常是一个客户和一个服务器）在彼此交换数据包之前必须先建立一个TCP连接。这一过程与打电话很相似，先拨号振铃，等待对方摘机说“喂”，然后才说明是谁。在一个TCP连接中，仅有两方进行彼此通信。而UDP更像是发短信，将发送方所有的信息，将所有信息一股脑儿全扔到网络中。"></a><strong>工作机制</strong>：紧小细微型。面向连接意味着两个使用TCP的应用（通常是一个客户和一个服务器）在彼此交换数据包之前必须先建立一个TCP连接。这一过程与打电话很相似，先拨号振铃，等待对方摘机说“喂”，然后才说明是谁。在一个TCP连接中，仅有两方进行彼此通信。而UDP更像是发短信，将发送方所有的信息，将所有信息一股脑儿全扔到网络中。</h5><h5 id="优势：可靠性好"><a href="#优势：可靠性好" class="headerlink" title="优势：可靠性好"></a><strong>优势</strong>：可靠性好</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">TCP如何实现可靠性？</span><br><span class="line">1.当TCP发出一个段后，它启动一个定时器，等待目的端确认收到这个报文段。如果不能及时收到一个确认，将重发这个报文段。当TCP收到发自TCP连接另一端的数据，它将发送一个确认。TCP有延迟确认的功能，在此功能没有打开，则是立即确认。功能打开，则由定时器触发确认时间点。</span><br><span class="line"></span><br><span class="line">2.TCP将保持它首部和数据的检验和。这是一个端到端的检验和，目的是检测数据在传输过程中的任何变化。如果收到段的检验和有差错，TCP将丢弃这个报文段和不确认收到此报文段（希望发端超时并重发）</span><br><span class="line"></span><br><span class="line">3.既然TCP报文段作为IP数据报来传输，而IP数据报的到达可能会失序，因此TCP报文段的到达也可能会失序。如果必要，TCP将对收到的数据进行重新排序，将收到的数据以正确的顺序交给应用层。</span><br><span class="line"></span><br><span class="line">4.TCP的接收端必须丢弃重复的数据</span><br><span class="line"></span><br><span class="line">5.量控制。TCP连接的每一方都有固定大小的缓冲空间。TCP的接收端只允许另一端发送接收端缓冲区所能接纳的数据。这将防止较快主机致使较慢主机的缓冲区溢出。</span><br></pre></td></tr></table></figure>
<h5 id="劣势：速度慢，占用系统资源高，易被攻击"><a href="#劣势：速度慢，占用系统资源高，易被攻击" class="headerlink" title="劣势：速度慢，占用系统资源高，易被攻击"></a><strong>劣势</strong>：速度慢，占用系统资源高，易被攻击</h5><p>TCP在传递数据之前，要先建连接，这会消耗时间，而且在数据传递时，确认机制、重传机制、拥塞控制机制等都会消耗大量的时间。<br>由于在每台设备上都需要维护所有的传输连接，而每个连接都会占用系统的CPU、内存等硬件资源。<br>此外，由于TCP有确认机制、三次握手机制，这些也导致TCP容易被人利用，实现DOS、DDOS、CC等攻击。</p>
<h5 id="应用-1"><a href="#应用-1" class="headerlink" title="应用"></a><strong>应用</strong></h5><p>当对网络通讯质量有要求的时候，比如：整个数据要<strong>准确无误</strong>的传递给对方，这往往用于一些要求可靠的应用，比如HTTP、HTTPS、FTP等传输文件的协议，POP、SMTP等邮件传输的协议。<br>在日常生活中，常见使用TCP协议的应用如下： 浏览器，用的HTTP FlashFXP，用的FTP Outlook，用的POP、SMTP Putty，用的Telnet、SSH QQ文件传输</p>
<h1 id="面向连接的-TCP"><a href="#面向连接的-TCP" class="headerlink" title="面向连接的 TCP"></a>面向连接的 TCP</h1><p>“面向连接” 就是在正式通信前必须要与对方建立起连接。比如你给别人打电话，必须等线路接通了、对方拿起话筒才能相互通话。</p>
<p>TCP（Transmission Control Protocol，<a href="https://baike.baidu.com/item/%E4%BC%A0%E8%BE%93%E6%8E%A7%E5%88%B6%E5%8D%8F%E8%AE%AE" target="_blank" rel="noopener">传输控制协议</a>）是基于连接的协议，也就是说，在正式收发数据前，必须和对方建立可靠的连接。一个 TCP 连接必须要经过三次 “对话” 才能建立起来，其中的过程非常复杂，我们这里只做简单、形象的介绍，你只要做到能够理解这个过程即可。我们来看看这三次对话的简单过程：主机 A 向主机 B 发出连接请求数据包：“我想给你发数据，可以吗？”，这是第一次对话；主机 B 向主机</p>
<p> <img src="https://gss2.bdstatic.com/9fo3dSag_xI4khGkpoWK1HF6hhy/baike/s%3D220/sign=2179100cf21fbe09185ec4165b610c30/0df431adcbef76091184b6e52edda3cc7cd99e38.jpg" alt=""></p>
<p>A 发送同意连接和要求同步（同步就是两台主机一个在发送，一个在接收，协调工作）的数据包：“可以，你什么时候发？”，这是第二次对话；主机 A 再发出一个数据包确认主机 B 的要求同步：“我现在就发，你接着吧！”，这是第三次对话。三次 “对话” 的目的是使数据包的发送和接收同步，经过三次 “对话” 之后，主机A 才向主机 B 正式发送数据。</p>
<p>TCP 协议能为应用程序提供可靠的通信连接，使一台计算机发出的字节流无差错地发往网络上的其他计算机，对可靠性要求高的数据通信系统往往使用 TCP 协议传输数据。</p>
<p>我们来做一个实验，用计算机 A（安装 Windows 2000 Server 操作系统）从 “网上邻居” 上的一台计算机 B 拷贝大小为 8,644,608 字节的文件，通过状态栏右下角网卡的发送和接收指标就会发现：虽然是数据流是由计算机 B 流向计算机 A，但是计算机 A 仍发送了 3,456 个数据包，如图 2 所示。这些数据包是怎样产生</p>
<p> <img src="https://gss3.bdstatic.com/-Po3dSag_xI4khGkpoWK1HF6hhy/baike/s%3D220/sign=43802ed1033b5bb5bad727fc06d2d523/2e2eb9389b504fc2bed69f7fe5dde71190ef6d3a.jpg" alt=""></p>
<p>的呢？因为文件传输时使用了 <a href="https://baike.baidu.com/item/TCP%2FIP%E5%8D%8F%E8%AE%AE" target="_blank" rel="noopener">TCP/IP 协议</a>，更确切地说是使用了面向连接的 TCP 协议，计算机 A 接收数据包的时候，要向计算机 B 回发数据包，所以也产生了一些通信量。</p>
<p>如果事先用网络监视器监视网络流量，就会发现由此产生的数据流量是 9,478,819 字节，比文件大小多出 10.96%（如图 3 所示），原因不仅在于数据包和帧本身占用了一些空间，而且也在于 TCP 协议面向连接的特性导致了一些额外的通信量的产生。</p>
<h1 id="面向非连接的-UDP-协议"><a href="#面向非连接的-UDP-协议" class="headerlink" title="面向非连接的 UDP 协议"></a>面向非连接的 UDP 协议</h1><p>“面向非连接” 就是在正式通信前不必与对方先建立连接，不管对方状态就直接发送。与手机短信非常相似：你在发短信的时候，只需要输入对方手机号就 OK 了。</p>
<p>UDP（User Data Protocol，<a href="https://baike.baidu.com/item/%E7%94%A8%E6%88%B7%E6%95%B0%E6%8D%AE%E6%8A%A5%E5%8D%8F%E8%AE%AE" target="_blank" rel="noopener">用户数据报协议</a>）是与 TCP 相对应的协议。它是面向非连接的协议，它不与对方建立连接，而是直接就把数据包发送过去！</p>
<p> <img src="https://gss0.bdstatic.com/-4o3dSag_xI4khGkpoWK1HF6hhy/baike/s%3D220/sign=fabf517cacaf2eddd0f14eebbd110102/574e9258d109b3de1034cb12ccbf6c81810a4cc4.jpg" alt=""></p>
<p>UDP 适用于一次只传送少量数据、对可靠性要求不高的应用环境。比如，我们经常使用 “ping” 命令来测试两台主机之间 TCP/IP 通信是否正常，其实 “ping” 命令的原理就是向对方主机发送 ICMP 数据包，然后对方主机确认收到数据包，如果数据包是否到达的消息及时反馈回来，那么网络就是通的。例如，在默认状态下，一次 “ping” 操作发送 4 个数据包（如图所示）。大家可以看到，发送的数据包数量是 4 包，收到的也是 4 包（因为对方主机收到后会发回一个确认收到的数据包）。这充分说明了 UDP 协议是面向非连接的协议，没有建立连接的过程。正因为 UDP 协议没有连接的过程，所以它的通信效率高；但也正因为如此，它的可靠性不如 TCP 协议高。QQ 就使用 UDP 发消息，因此有时会出现收不到消息的情况。</p>

        </div>
    

</div>
            
                
<div class="post">

    <div class="post-header index">
        <h1 class="title">
            <a href="/2018/08/03/error-collections/">
                error collections
            </a>
        </h1>
        <div class="post-info">
            
                <span class="date">2018-08-03</span>
            
            
            
        </div>
    </div>

    
        <div class="content">
            <h2 id="github"><a href="#github" class="headerlink" title="github"></a>github</h2><p>error:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">RPC failed; curl 52 Empty reply from server</span><br></pre></td></tr></table></figure></p>
<p>solved:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git config --global http.postBuffer 157286400</span><br></pre></td></tr></table></figure></p>
<h2 id="mysql"><a href="#mysql" class="headerlink" title="mysql"></a>mysql</h2><p>error:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Expression #2 of SELECT list is not in GROUP BY clause and contains </span><br><span class="line">nonaggregated column ‘sss.month_id’ which is not functionally </span><br><span class="line">dependent on columns in GROUP BY clause; this is incompatible with </span><br><span class="line">sql_mode=only_full_group_by</span><br></pre></td></tr></table></figure></p>
<p>solved: </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">打开navcat，</span><br><span class="line"></span><br><span class="line">用sql查询：</span><br><span class="line"></span><br><span class="line">select @@global.sql_mode</span><br><span class="line"></span><br><span class="line">查询出来的值为：</span><br><span class="line"></span><br><span class="line">ONLY_FULL_GROUP_BY,STRICT_TRANS_TABLES,NO_ZERO_IN_DATE,NO_ZERO_DATE,ERROR_FOR_DIVISION_BY_ZERO,NO_AUTO_CREATE_USER,NO_ENGINE_SUBSTITUTION</span><br><span class="line"></span><br><span class="line">去掉ONLY_FULL_GROUP_BY，重新设置值。</span><br><span class="line"></span><br><span class="line">set @@global.sql_mode </span><br><span class="line">=’STRICT_TRANS_TABLES,NO_ZERO_IN_DATE,NO_ZERO_DATE,ERROR_FOR_DIVISION_BY_ZERO,NO_AUTO_CREATE_USER,NO_ENGINE_SUBSTITUTION’;</span><br></pre></td></tr></table></figure>

        </div>
    

</div>
            
                
<div class="post">

    <div class="post-header index">
        <h1 class="title">
            <a href="/2018/08/02/HashMap底层分析/">
                HashMap底层分析
            </a>
        </h1>
        <div class="post-info">
            
                <span class="date">2018-08-02</span>
            
            
            
        </div>
    </div>

    
        <div class="content">
            <h1 id="HashMap-底层分析"><a href="#HashMap-底层分析" class="headerlink" title="HashMap 底层分析"></a>HashMap 底层分析</h1><blockquote>
<p>以下基于 JDK1.7 分析。</p>
</blockquote>
<p><img src="https://ws2.sinaimg.cn/large/006tNc79gy1fn84b0ftj4j30eb0560sv.jpg" alt=""></p>
<p>如图所示，HashMap 底层是基于数组和链表实现的。其中有两个重要的参数：</p>
<ul>
<li>容量</li>
<li>负载因子</li>
</ul>
<p>容量的默认大小是 16，负载因子是 0.75，当 <code>HashMap</code> 的 <code>size &gt; 16*0.75</code> 时就会发生扩容(容量和负载因子都可以自由调整)。</p>
<h2 id="put-方法"><a href="#put-方法" class="headerlink" title="put 方法"></a>put 方法</h2><p>首先会将传入的 Key 做 <code>hash</code> 运算计算出 hashcode,然后根据数组长度取模计算出在数组中的 index 下标。</p>
<p>由于在计算中位运算比取模运算效率高的多，所以 HashMap 规定数组的长度为 <code>2^n</code> 。这样用 <code>2^n - 1</code> 做位运算与取模效果一致，并且效率还要高出许多。</p>
<p>由于数组的长度有限，所以难免会出现不同的 Key 通过运算得到的 index 相同，这种情况可以利用链表来解决，HashMap 会在 <code>table[index]</code>处形成链表，采用头插法将数据插入到链表中。</p>
<h2 id="get-方法"><a href="#get-方法" class="headerlink" title="get 方法"></a>get 方法</h2><p>get 和 put 类似，也是将传入的 Key 计算出 index ，如果该位置上是一个链表就需要遍历整个链表，通过 <code>key.equals(k)</code> 来找到对应的元素。</p>
<h2 id="遍历方式"><a href="#遍历方式" class="headerlink" title="遍历方式"></a>遍历方式</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Iterator&lt;Map.Entry&lt;String, Integer&gt;&gt; entryIterator = map.entrySet().iterator();</span><br><span class="line">       <span class="keyword">while</span> (entryIterator.hasNext()) &#123;</span><br><span class="line">           Map.Entry&lt;String, Integer&gt; next = entryIterator.next();</span><br><span class="line">           System.out.println(<span class="string">"key="</span> + next.getKey() + <span class="string">" value="</span> + next.getValue());</span><br><span class="line">       &#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Iterator&lt;String&gt; iterator = map.keySet().iterator();</span><br><span class="line">        <span class="keyword">while</span> (iterator.hasNext())&#123;</span><br><span class="line">            String key = iterator.next();</span><br><span class="line">            System.out.println(<span class="string">"key="</span> + key + <span class="string">" value="</span> + map.get(key));</span><br><span class="line"></span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">map.forEach((key,value)-&gt;&#123;</span><br><span class="line">    System.out.println(<span class="string">"key="</span> + key + <span class="string">" value="</span> + value);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p><strong>强烈建议</strong>使用第一种 EntrySet 进行遍历。</p>
<p>第一种可以把 key value 同时取出，第二种还得需要通过 key 取一次 value，效率较低, 第三种需要 <code>JDK1.8</code> 以上，通过外层遍历 table，内层遍历链表或红黑树。 </p>
<h2 id="notice"><a href="#notice" class="headerlink" title="notice"></a>notice</h2><p>在并发环境下使用 <code>HashMap</code> 容易出现死循环。</p>
<p>并发场景发生扩容，调用 <code>resize()</code> 方法里的 <code>rehash()</code> 时，容易出现环形链表。这样当获取一个不存在的 <code>key</code> 时，计算出的 <code>index</code> 正好是环形链表的下标时就会出现死循环。</p>
<p><img src="https://ws2.sinaimg.cn/large/006tNc79gy1fn85u0a0d9j30n20ii0tp.jpg" alt=""></p>
<blockquote>
<p>所以 HashMap 只能在单线程中使用，并且尽量的预设容量，尽可能的减少扩容。</p>
</blockquote>
<p>在 <code>JDK1.8</code> 中对 <code>HashMap</code> 进行了优化：<br>当 <code>hash</code> 碰撞之后写入链表的长度超过了阈值(默认为8)，链表将会转换为<strong>红黑树</strong>。</p>
<p>假设 <code>hash</code> 冲突非常严重，一个数组后面接了很长的链表，此时重新的时间复杂度就是 <code>O(n)</code> 。</p>
<p>如果是红黑树，时间复杂度就是 <code>O(logn)</code> 。</p>
<p>大大提高了查询效率。</p>
<h3 id="附录："><a href="#附录：" class="headerlink" title="附录："></a>附录：</h3><p><a href="https://mp.weixin.qq.com/s?__biz=MzIxMjE5MTE1Nw==&amp;mid=2653191907&amp;idx=1&amp;sn=876860c5a9a6710ead5dd8de37403ffc&amp;chksm=8c990c39bbee852f71c9dfc587fd70d10b0eab1cca17123c0a68bf1e16d46d71717712b91509&amp;scene=21#wechat_redirect" target="_blank" rel="noopener">什么是HashMap？</a></p>
<p><a href="https://mp.weixin.qq.com/s?__biz=MzIxMjE5MTE1Nw==&amp;mid=2653192000&amp;idx=1&amp;sn=118cee6d1c67e7b8e4f762af3e61643e&amp;chksm=8c990d9abbee848c739aeaf25893ae4382eca90642f65fc9b8eb76d58d6e7adebe65da03f80d&amp;scene=21#wechat_redirect" target="_blank" rel="noopener">高并发下的HashMap</a></p>
<p><a href="https://mp.weixin.qq.com/s?__biz=MzIxMjE5MTE1Nw==&amp;mid=2653192083&amp;idx=1&amp;sn=5c4becd5724dd72ad489b9ed466329f5&amp;chksm=8c990d49bbee845f69345e4121888ec967df27988bc66afd984a25331d2f6464a61dc0335a54&amp;scene=21#wechat_redirect" target="_blank" rel="noopener">什么是ConcurrentHashMap？</a></p>
<p><a href="https://mp.weixin.qq.com/s?__biz=MzIxMjE5MTE1Nw==&amp;mid=2653191832&amp;idx=1&amp;sn=12017161025495c6914b5ab9397baa59&amp;chksm=8c990c42bbee8554ba02eb83d839123bd3bead6ffc736111456ea77367a3df75750cf88016e0&amp;scene=21#wechat_redirect" target="_blank" rel="noopener">什么是红黑树？</a></p>

        </div>
    

</div>
            
                
<div class="post">

    <div class="post-header index">
        <h1 class="title">
            <a href="/2018/08/02/LinkedList底层分析/">
                LinkedList底层分析
            </a>
        </h1>
        <div class="post-info">
            
                <span class="date">2018-08-02</span>
            
            
            
        </div>
    </div>

    
        <div class="content">
            <p><img src="https://ws4.sinaimg.cn/large/006tKfTcly1fqzb66c00gj30p7056q38.jpg" alt=""></p>
<p>如图所示 <code>LinkedList</code> 底层是基于双向链表实现的，也是实现了 <code>List</code> 接口，所以也拥有 List 的一些特点(JDK1.7/8 之后取消了循环，修改为双向链表)。</p>
<h2 id="新增方法"><a href="#新增方法" class="headerlink" title="新增方法"></a>新增方法</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">add</span><span class="params">(E e)</span> </span>&#123;</span><br><span class="line">    linkLast(e);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"> <span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Links e as last element.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">linkLast</span><span class="params">(E e)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> Node&lt;E&gt; l = last;</span><br><span class="line">    <span class="keyword">final</span> Node&lt;E&gt; newNode = <span class="keyword">new</span> Node&lt;&gt;(l, e, <span class="keyword">null</span>);</span><br><span class="line">    last = newNode;</span><br><span class="line">    <span class="keyword">if</span> (l == <span class="keyword">null</span>)</span><br><span class="line">        first = newNode;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        l.next = newNode;</span><br><span class="line">    size++;</span><br><span class="line">    modCount++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可见每次插入都是移动指针，和 ArrayList 的拷贝数组来说效率要高上不少。</p>
<h2 id="查询方法"><a href="#查询方法" class="headerlink" title="查询方法"></a>查询方法</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> E <span class="title">get</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">    checkElementIndex(index);</span><br><span class="line">    <span class="keyword">return</span> node(index).item;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">Node&lt;E&gt; <span class="title">node</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// assert isElementIndex(index);</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (index &lt; (size &gt;&gt; <span class="number">1</span>)) &#123;</span><br><span class="line">        Node&lt;E&gt; x = first;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; index; i++)</span><br><span class="line">            x = x.next;</span><br><span class="line">        <span class="keyword">return</span> x;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        Node&lt;E&gt; x = last;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = size - <span class="number">1</span>; i &gt; index; i--)</span><br><span class="line">            x = x.prev;</span><br><span class="line">        <span class="keyword">return</span> x;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>由此可以看出是使用二分查找来看 <code>index</code> 离 size 中间距离来判断是从头节点正序查还是从尾节点倒序查。</p>
<ul>
<li><code>node()</code>会以<code>O(n/2)</code>(二分查找算法)的性能去获取一个结点<ul>
<li>如果索引值大于链表大小的一半，那么将从尾结点开始遍历</li>
</ul>
</li>
</ul>
<p>这样的效率是非常低的，特别是当 index 越接近 size 的中间值时。</p>
<p>总结：</p>
<ul>
<li>LinkedList 插入，删除都是移动指针效率很高。</li>
<li>查找需要进行遍历查询，效率较低。</li>
</ul>

        </div>
    

</div>
            
                
<div class="post">

    <div class="post-header index">
        <h1 class="title">
            <a href="/2018/08/02/ArrayListVector的底层分析/">
                ArrayList/Vector的底层分析
            </a>
        </h1>
        <div class="post-info">
            
                <span class="date">2018-08-02</span>
            
            
            
        </div>
    </div>

    
        <div class="content">
            <h2 id="ArrayList"><a href="#ArrayList" class="headerlink" title="ArrayList"></a>ArrayList</h2><p><code>ArrayList</code> 实现于 <code>List</code>、<code>RandomAccess</code> 接口。可以插入空数据，也支持随机访问。</p>
<p><code>ArrayList</code>相当于动态数据，其中最重要的两个属性分别是: <code>elementData</code> 数组，以及 <code>size</code> 大小。 在调用 <code>add()</code> 方法的时候：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">add</span><span class="params">(E e)</span> </span>&#123;</span><br><span class="line">    ensureCapacityInternal(size + <span class="number">1</span>);  <span class="comment">// Increments modCount!!</span></span><br><span class="line">    elementData[size++] = e;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>首先进行扩容校验。</li>
<li>将插入的值放到尾部，并将 size + 1 。</li>
</ul>
<p>如果是调用 <code>add(index,e)</code> 在指定位置添加的话：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> index, E element)</span> </span>&#123;</span><br><span class="line">    rangeCheckForAdd(index);</span><br><span class="line"></span><br><span class="line">    ensureCapacityInternal(size + <span class="number">1</span>);  <span class="comment">// Increments modCount!!</span></span><br><span class="line">    <span class="comment">//复制，向后移动</span></span><br><span class="line">    System.arraycopy(elementData, index, elementData, index + <span class="number">1</span>,</span><br><span class="line">                     size - index);</span><br><span class="line">    elementData[index] = element;</span><br><span class="line">    size++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>也是首先扩容校验。</li>
<li>接着对数据进行复制，目的是把 index 位置空出来放本次插入的数据，并将后面的数据向后移动一个位置。</li>
</ul>
<p>其实扩容最终调用的代码:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">grow</span><span class="params">(<span class="keyword">int</span> minCapacity)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// overflow-conscious code</span></span><br><span class="line">    <span class="keyword">int</span> oldCapacity = elementData.length;</span><br><span class="line">    <span class="keyword">int</span> newCapacity = oldCapacity + (oldCapacity &gt;&gt; <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">if</span> (newCapacity - minCapacity &lt; <span class="number">0</span>)</span><br><span class="line">        newCapacity = minCapacity;</span><br><span class="line">    <span class="keyword">if</span> (newCapacity - MAX_ARRAY_SIZE &gt; <span class="number">0</span>)</span><br><span class="line">        newCapacity = hugeCapacity(minCapacity);</span><br><span class="line">    <span class="comment">// minCapacity is usually close to size, so this is a win:</span></span><br><span class="line">    elementData = Arrays.copyOf(elementData, newCapacity);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>也是一个数组复制的过程。</p>
<p>由此可见 <code>ArrayList</code> 的主要消耗是数组扩容以及在指定位置添加数据，在日常使用时最好是指定大小，尽量减少扩容。更要减少在指定位置插入数据的操作。</p>
<h3 id="序列化"><a href="#序列化" class="headerlink" title="序列化"></a>序列化</h3><p>由于 ArrayList 是基于动态数组实现的，所以并不是所有的空间都被使用。因此使用了 <code>transient</code> 修饰，可以防止被自动序列化。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">transient</span> Object[] elementData;</span><br></pre></td></tr></table></figure>
<p>因此 ArrayList 自定义了序列化与反序列化：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">writeObject</span><span class="params">(java.io.ObjectOutputStream s)</span></span></span><br><span class="line"><span class="function">    <span class="keyword">throws</span> java.io.IOException</span>&#123;</span><br><span class="line">    <span class="comment">// Write out element count, and any hidden stuff</span></span><br><span class="line">    <span class="keyword">int</span> expectedModCount = modCount;</span><br><span class="line">    s.defaultWriteObject();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Write out size as capacity for behavioural compatibility with clone()</span></span><br><span class="line">    s.writeInt(size);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Write out all elements in the proper order.</span></span><br><span class="line">    <span class="comment">//只序列化了被使用的数据</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;size; i++) &#123;</span><br><span class="line">        s.writeObject(elementData[i]);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (modCount != expectedModCount) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> ConcurrentModificationException();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">readObject</span><span class="params">(java.io.ObjectInputStream s)</span></span></span><br><span class="line"><span class="function">    <span class="keyword">throws</span> java.io.IOException, ClassNotFoundException </span>&#123;</span><br><span class="line">    elementData = EMPTY_ELEMENTDATA;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Read in size, and any hidden stuff</span></span><br><span class="line">    s.defaultReadObject();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Read in capacity</span></span><br><span class="line">    s.readInt(); <span class="comment">// ignored</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (size &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// be like clone(), allocate array based upon size not capacity</span></span><br><span class="line">        ensureCapacityInternal(size);</span><br><span class="line"></span><br><span class="line">        Object[] a = elementData;</span><br><span class="line">        <span class="comment">// Read in all elements in the proper order.</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;size; i++) &#123;</span><br><span class="line">            a[i] = s.readObject();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>当对象中自定义了 writeObject 和 readObject 方法时，JVM 会调用这两个自定义方法来实现序列化与反序列化。</p>
</blockquote>
<p>从实现中可以看出 ArrayList 只序列化了被使用的数据。</p>
<h2 id="Vector"><a href="#Vector" class="headerlink" title="Vector"></a>Vector</h2><p><code>Vector</code> 也是实现于 <code>List</code> 接口，底层数据结构和 <code>ArrayList</code> 类似,也是一个动态数组存放数据。不过是在 <code>add()</code> 方法的时候使用 <code>synchronized</code> 进行同步写数据，但是开销较大，所以 <code>Vector</code> 是一个同步容器并不是一个并发容器。</p>
<p>以下是 <code>add()</code> 方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">boolean</span> <span class="title">add</span><span class="params">(E e)</span> </span>&#123;</span><br><span class="line">    modCount++;</span><br><span class="line">    ensureCapacityHelper(elementCount + <span class="number">1</span>);</span><br><span class="line">    elementData[elementCount++] = e;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>以及指定位置插入数据:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> index, E element)</span> </span>&#123;</span><br><span class="line">    insertElementAt(element, index);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">insertElementAt</span><span class="params">(E obj, <span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">    modCount++;</span><br><span class="line">    <span class="keyword">if</span> (index &gt; elementCount) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> ArrayIndexOutOfBoundsException(index</span><br><span class="line">                                                 + <span class="string">" &gt; "</span> + elementCount);</span><br><span class="line">    &#125;</span><br><span class="line">    ensureCapacityHelper(elementCount + <span class="number">1</span>);</span><br><span class="line">    System.arraycopy(elementData, index, elementData, index + <span class="number">1</span>, elementCount - index);</span><br><span class="line">    elementData[index] = obj;</span><br><span class="line">    elementCount++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="数组的复制"><a href="#数组的复制" class="headerlink" title="数组的复制"></a>数组的复制</h3><p>System提供了一个静态方法arraycopy(),我们可以使用它来实现数组之间的复制。其函数原型是：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">arraycopy</span><span class="params">(Object src,</span></span></span><br><span class="line"><span class="function"><span class="params">                             <span class="keyword">int</span> srcPos,</span></span></span><br><span class="line"><span class="function"><span class="params">                             Object dest,</span></span></span><br><span class="line"><span class="function"><span class="params">                             <span class="keyword">int</span> destPos,</span></span></span><br><span class="line"><span class="function"><span class="params">                             <span class="keyword">int</span> length)</span></span></span><br></pre></td></tr></table></figure>
<p>src:源数组；    srcPos:源数组要复制的起始位置；</p>
<p>dest:目的数组；    destPos:目的数组放置的起始位置；    length:复制的长度。</p>
<p>注意：src and dest都必须是同类型或者可以进行转换类型的数组．</p>
<p>有趣的是这个函数可以实现自己到自己复制，比如：</p>
<p>int[] fun ={0,1,2,3,4,5,6}; </p>
<p>System.arraycopy(fun,0,fun,3,3);</p>
<p>则结果为：{0,1,2,0,1,2,6};</p>
<p>实现过程是这样的，先生成一个长度为length的临时数组,将fun数组中srcPos </p>
<p>到srcPos+length-1之间的数据拷贝到临时数组中，再执行System.arraycopy(临时数组,0,fun,3,3).</p>
<h3 id="移位运算符"><a href="#移位运算符" class="headerlink" title="移位运算符"></a>移位运算符</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;&lt;      :     左移运算符，num &lt;&lt; 1,相当于num乘以2</span><br><span class="line"></span><br><span class="line">&gt;&gt;      :     右移运算符，num &gt;&gt; 1,相当于num除以2</span><br><span class="line"></span><br><span class="line">&gt;&gt;&gt;    :     无符号右移，忽略符号位，空位都以0补齐</span><br></pre></td></tr></table></figure>

        </div>
    

</div>
            
                
<div class="post">

    <div class="post-header index">
        <h1 class="title">
            <a href="/2018/07/23/Spring整合Shiro的配置/">
                Spring整合Shiro的配置
            </a>
        </h1>
        <div class="post-info">
            
                <span class="date">2018-07-23</span>
            
            
            
        </div>
    </div>

    
        <div class="content">
            <h2 id="spring-shiro-xml"><a href="#spring-shiro-xml" class="headerlink" title="spring-shiro.xml"></a>spring-shiro.xml</h2><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</span><br><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns</span>=<span class="string">"http://www.springframework.org/schema/beans"</span></span></span><br><span class="line"><span class="tag">	<span class="attr">xmlns:xsi</span>=<span class="string">"http://www.w3.org/2001/XMLSchema-instance"</span> </span></span><br><span class="line"><span class="tag">	<span class="attr">xmlns:aop</span>=<span class="string">"http://www.springframework.org/schema/aop"</span></span></span><br><span class="line"><span class="tag">	<span class="attr">xmlns:tx</span>=<span class="string">"http://www.springframework.org/schema/tx"</span> </span></span><br><span class="line"><span class="tag">	<span class="attr">xmlns:util</span>=<span class="string">"http://www.springframework.org/schema/util"</span></span></span><br><span class="line"><span class="tag">	<span class="attr">xmlns:context</span>=<span class="string">"http://www.springframework.org/schema/context"</span></span></span><br><span class="line"><span class="tag">	<span class="attr">xsi:schemaLocation</span>=<span class="string">"</span></span></span><br><span class="line"><span class="tag"><span class="string">       http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd</span></span></span><br><span class="line"><span class="tag"><span class="string">       http://www.springframework.org/schema/tx http://www.springframework.org/schema/tx/spring-tx.xsd</span></span></span><br><span class="line"><span class="tag"><span class="string">       http://www.springframework.org/schema/aop http://www.springframework.org/schema/aop/spring-aop.xsd</span></span></span><br><span class="line"><span class="tag"><span class="string">       http://www.springframework.org/schema/util http://www.springframework.org/schema/util/spring-util.xsd</span></span></span><br><span class="line"><span class="tag"><span class="string">       http://www.springframework.org/schema/context </span></span></span><br><span class="line"><span class="tag"><span class="string">       http://www.springframework.org/schema/context/spring-context.xsd"</span>&gt;</span></span><br><span class="line">	 <span class="comment">&lt;!-- shiro工厂bean配置 --&gt;</span></span><br><span class="line">     <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"shiroFilter"</span> <span class="attr">class</span>=<span class="string">"org.apache.shiro.spring.web.ShiroFilterFactoryBean"</span>&gt;</span></span><br><span class="line">         <span class="comment">&lt;!-- shiro的核心安全接口 --&gt;</span></span><br><span class="line">         <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"securityManager"</span> <span class="attr">ref</span>=<span class="string">"securityManager"</span>/&gt;</span></span><br><span class="line">         <span class="comment">&lt;!-- 要求登录时的连接 --&gt;</span></span><br><span class="line">         <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"loginUrl"</span> <span class="attr">value</span>=<span class="string">"/loginUI.do"</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">         <span class="comment">&lt;!-- 登录成功后要跳转的连接(此处已经在登录中处理了) --&gt;</span></span><br><span class="line">         <span class="comment">&lt;!-- &lt;property name="successUrl" value="/index.jsp"&gt;&lt;/property&gt; --&gt;</span></span><br><span class="line">         <span class="comment">&lt;!-- 访问未对其授权的资源时,要跳转的连接 </span></span><br><span class="line"><span class="comment">         &lt;property name="unauthorizedUrl" value="/default.html"&gt;&lt;/property&gt;--&gt;</span></span><br><span class="line">         <span class="comment">&lt;!-- shiro连接约束配置 --&gt;</span></span><br><span class="line">         <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"filterChainDefinitions"</span>&gt;</span></span><br><span class="line">             <span class="tag">&lt;<span class="name">value</span>&gt;</span></span><br><span class="line">                 <span class="comment">&lt;!-- 对静态资源设置允许匿名访问 --&gt;</span></span><br><span class="line">                 /images/** = anon</span><br><span class="line">                 /js/** = anon</span><br><span class="line">                 /css/** = anon</span><br><span class="line">                 /static/** = anon</span><br><span class="line">                 /bootstrap/** = anon</span><br><span class="line">                 /jquery/** = anon</span><br><span class="line">                 <span class="comment">&lt;!-- 可匿名访问路径，例如：验证码、登录连接、退出连接等 --&gt;</span></span><br><span class="line">                 /login.do = anon</span><br><span class="line">                 <span class="comment">&lt;!-- 退出 --&gt;</span></span><br><span class="line">                 /logout.do = logout  <span class="comment">&lt;!-- 会调用Subject的logout方法,此方法会将session清空 --&gt;</span></span><br><span class="line">                 <span class="comment">&lt;!-- 剩余其他路径，必须认证通过才可以访问 --&gt;</span></span><br><span class="line">                 /** = authc</span><br><span class="line">             <span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">         <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">     <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line">     <span class="comment">&lt;!-- 配置shiro安全管理器 --&gt;</span></span><br><span class="line">     <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"securityManager"</span> <span class="attr">class</span>=<span class="string">"org.apache.shiro.web.mgt.DefaultWebSecurityManager"</span>&gt;</span></span><br><span class="line">         <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"realm"</span> <span class="attr">ref</span>=<span class="string">"shiroUserRealm"</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">     <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line">     <span class="comment">&lt;!-- 自定义Realm --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"shiroUserRealm"</span> <span class="attr">class</span>=<span class="string">"com.olive.demo.common.service.impl.ShiroUserRealm"</span>&gt;</span></span><br><span class="line">    	<span class="comment">&lt;!-- 配置凭证算法匹配器 --&gt;</span></span><br><span class="line">    	<span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"credentialsMatcher"</span>&gt;</span></span><br><span class="line">    		<span class="tag">&lt;<span class="name">bean</span> <span class="attr">class</span>=<span class="string">"org.apache.shiro.authc.credential.HashedCredentialsMatcher"</span>&gt;</span></span><br><span class="line">    			<span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"hashAlgorithmName"</span> <span class="attr">value</span>=<span class="string">"MD5"</span>/&gt;</span></span><br><span class="line">    			<span class="comment">&lt;!-- &lt;property name="hashIterations" value="1024"/&gt; --&gt;</span></span><br><span class="line">    		<span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line">    	<span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line">	<span class="comment">&lt;!--Shiro生命周期处理器--&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"lifecycleBeanPostProcessor"</span> <span class="attr">class</span>=<span class="string">"org.apache.shiro.spring.LifecycleBeanPostProcessor"</span>/&gt;</span></span><br><span class="line">	</span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h2 id="web-xml"><a href="#web-xml" class="headerlink" title="web.xml"></a>web.xml</h2><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</span><br><span class="line"><span class="tag">&lt;<span class="name">web-app</span> <span class="attr">xmlns:xsi</span>=<span class="string">"http://www.w3.org/2001/XMLSchema-instance"</span> <span class="attr">xmlns</span>=<span class="string">"http://java.sun.com/xml/ns/javaee"</span> <span class="attr">xsi:schemaLocation</span>=<span class="string">"http://java.sun.com/xml/ns/javaee http://java.sun.com/xml/ns/javaee/web-app_2_5.xsd"</span> <span class="attr">version</span>=<span class="string">"2.5"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">display-name</span>&gt;</span>demo<span class="tag">&lt;/<span class="name">display-name</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">servlet</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">servlet-name</span>&gt;</span>dispatcherServlet<span class="tag">&lt;/<span class="name">servlet-name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">servlet-class</span>&gt;</span>org.springframework.web.servlet.DispatcherServlet<span class="tag">&lt;/<span class="name">servlet-class</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">init-param</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">param-name</span>&gt;</span>contextConfigLocation<span class="tag">&lt;/<span class="name">param-name</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">param-value</span>&gt;</span>classpath:spring-*.xml<span class="tag">&lt;/<span class="name">param-value</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">init-param</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">load-on-startup</span>&gt;</span>1<span class="tag">&lt;/<span class="name">load-on-startup</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">servlet</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">servlet-mapping</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">servlet-name</span>&gt;</span>dispatcherServlet<span class="tag">&lt;/<span class="name">servlet-name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">url-pattern</span>&gt;</span>*.do<span class="tag">&lt;/<span class="name">url-pattern</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">servlet-mapping</span>&gt;</span></span><br><span class="line">  <span class="comment">&lt;!-- spring整合shiro安全框架 --&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">filter</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">filter-name</span>&gt;</span>DelegatingFilterProxy<span class="tag">&lt;/<span class="name">filter-name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">filter-class</span>&gt;</span>org.springframework.web.filter.DelegatingFilterProxy<span class="tag">&lt;/<span class="name">filter-class</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 初始化参数 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">init-param</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">param-name</span>&gt;</span>targetBeanName<span class="tag">&lt;/<span class="name">param-name</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">param-value</span>&gt;</span>shiroFilter<span class="tag">&lt;/<span class="name">param-value</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">init-param</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">filter</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">filter-mapping</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">filter-name</span>&gt;</span>DelegatingFilterProxy<span class="tag">&lt;/<span class="name">filter-name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">url-pattern</span>&gt;</span>/*<span class="tag">&lt;/<span class="name">url-pattern</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">filter-mapping</span>&gt;</span></span><br><span class="line">  <span class="comment">&lt;!-- 欢迎页面 --&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">welcome-file-list</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">welcome-file</span>&gt;</span>default.html<span class="tag">&lt;/<span class="name">welcome-file</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">welcome-file-list</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">web-app</span>&gt;</span></span><br></pre></td></tr></table></figure>

        </div>
    

</div>
            
        </section>
    </div>
</div>



    <div class="row">
        <div class="col-sm-12">
            <div class="wrap-pagination">
                <a class="disabled" href="/">
                    <i class="fa fa-chevron-left" aria-hidden="true"></i>
                </a>
                <a class="" href="/page/2/">
                    <i class="fa fa-chevron-right" aria-hidden="true"></i>
                </a>
            </div>
        </div>
    </div>




</div>

<!-- Footer -->
<div class="push"></div>

<footer class="footer-content">
    <div class="container">
        <div class="row">
            <div class="col-xs-12 col-sm-12 col-md-6 col-lg-6 footer-about">
                <h2>About</h2>
                <p>
                    This is a personal technology blog.
                </p>
            </div>
            
    <div class="col-xs-6 col-sm-6 col-md-3 col-lg-3 recent-posts">
        <h2>Recent Posts</h2>
        <ul>
            
            <li>
                <a class="footer-post" href="/2018/08/16/MySQL/">MySQL</a>
            </li>
            
            <li>
                <a class="footer-post" href="/2018/08/16/SQL/">SQL</a>
            </li>
            
            <li>
                <a class="footer-post" href="/2018/08/16/数据库系统原理/">数据库系统原理</a>
            </li>
            
            <li>
                <a class="footer-post" href="/2018/08/16/反射工具类/">反射工具类</a>
            </li>
            
        </ul>
    </div>



            
        </div>
        <div class="row">
            <div class="col-xs-12 col-sm-12 col-md-12 col-lg-12">
                <ul class="list-inline footer-social-icons">
                    
                    
                    
                    
                    
                    
                    
                    
                    
                    
                </ul>
            </div>
        </div>
        <div class="row">
            <div class="col-xs-12 col-sm-12 col-md-12 col-lg-12">
                <div class="footer-copyright">
                    
                </div>
            </div>
        </div>
    </div>
</footer>

<!-- After footer scripts -->

<!-- jQuery -->
<script src="//code.jquery.com/jquery-2.1.4.min.js"></script>

<!-- Tween Max -->
<script src="//cdnjs.cloudflare.com/ajax/libs/gsap/1.18.5/TweenMax.min.js"></script>

<!-- Gallery -->
<script src="//cdnjs.cloudflare.com/ajax/libs/featherlight/1.3.5/featherlight.min.js" type="text/javascript" charset="utf-8"></script>

<!-- Custom JavaScript -->
<script src="/js/main.js"></script>

<!-- Disqus Comments -->



</body>

</html>